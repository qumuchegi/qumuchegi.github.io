{"title":"关于 Electron 进程间通信的一个小小实践","content":">Electron 是一个跨平台桌面框架，它集成了 node.js 和 chromium，所以我们可以借助 node.js 实现桌面客户端访问操作系统资源的功能（出于安全，浏览器是不可以访问操作系统的），而 chromium 允许我们使用前端工具HTML、JS、CSS 甚至结合 React、Vue 等渲染出用户界面。\n\n### 用进程间通信模拟实现 B/S 架构\n\nB/S 即 ‘浏览器/服务器’ 架构。既然 Electron 由 node.js 和 chromium 集成, 把 Electron 的渲染进程直接当作客户端浏览器进程，主进程当作服务器进程，把访问操作系统资源、读写文件等都放在主进程里，而渲染进程专心用于渲染页面和向主进程‘请求’操作资源，主进程和渲染进程之间可以实现进程间通信，可以模拟浏览器和服务器之间的 ajax 请求。\n\n一个结合 Electron  的项目架构：\n\n![image](/imgs_from_article/1577455791596__article-img__electron.png)\n\n下面以一个获取 github 用户信息和远程仓库的 Electron APP 为例，用具体的代码来展示如何实现\n\n渲染进程里使用 ipcRenderer 封装一个类 api 请求：\n```js\n// render/api.js\n\nvar electron = window.electron\nvar { ipcRenderer } = electron\nimport ipc_channel from '../const/ipc_channel'\n\nexport default {\n  loginGithub: ({username, password, cb}) => { // 登录 github 以创建一个 token\n  // 向主进程请求登录 GitHub\n    ipcRenderer.send(ipc_channel.LOGIN_GITHUB, {username, password})\n\n // 主进程完成登录后返回登录响应（比如一个token）\n    ipcRenderer.on(ipc_channel.LOGIN_GITHUB, (e, res) => {\n      cb(res)\n    })\n  }，\n  logoutGithub: ({username, password, id, cb}) => { // 退出登录\n    ipcRenderer.send(ipc_channel.LOGOUT_GITHUB, {username, password, id})\n\n    ipcRenderer.on(ipc_channel.LOGOUT_GITHUB, (e, res) => {\n      cb(res)\n    })\n  } \n}\n```\n主进程使用 ipcMain 将渲染进程的各个请求路由到相应的路由处理器,并且传递一个回调函数方便路由处理器向渲染进程发送响应：\n\n```js\n//main.js\n\nconst routes = require('./server-routes/routes')\n\nfor(let routeName in routes) {\n  ipcMain.on(routeName, (e, params) => {// 监听渲染进程各个 ‘请求’\n    routes[routeName]({ // 路由\n      params, // 请求参数\n      cb: (respond) => {// 回调函数用于向渲染进程发送响应\n        e.sender.send(routeName, respond)}\n      })\n    })\n}\n\n```\n\n路由处理器：\n\n```js\n// server-routes/routes.js\n\nvar github = require('octonode')// octonode 是一个 GitHub API 封装库\nvar ipc_channel = require('../../const/ipc_channel')\nconst fs = require('fs')\n\nconst {getABranchContent, readLocalDir_OR_FileWithPath, readAFile} = require('./middleweres')\n\nmodule.exports = {\n  [ipc_channel.LOGIN_GITHUB]: ({params, cb}) => {\n    let {username, password} = params\n\n    var scopes = {\n      'scopes': ['user', 'repo', 'gist'],\n      'note': 'admin script'\n    }\n    \n    github.auth.config({\n      username,\n      password\n    }).login(scopes, function (err, id, token, headers) {\n      console.log(id, token)\n      if(!err) cb({id, token})\n    })\n  },\n\n  [ipc_channel.LOGOUT_GITHUB]: ({params, cb}) => {\n    let {username, password, id} = params\n\n    github.auth.config({\n      username,\n      password\n    }).revoke(id, function (err) {\n      if (err) throw err\n      else cb({msg: '已经退出登录'})\n    })\n  }\n}\n```\n用一个单独的文件导出各个 ipc channel:\n```js\n// ipc_channel.js\n\nmodule.exports = {\n    LOGIN_GITHUB: 'login-github-for-token', // 登录 GitHub 以获取 token\n    LOGOUT_GITHUB: 'logout-and-revoke-token', // 退出登录并销毁 token\n    GET_REPO: 'get-a-repo', // 获取 github 上某个仓库的内容\n    READ_LOCAL_PATH: 'read-local-path', // 读取本地目录\n    READ_LOCAL_FILE: 'read-local-file', // 读取本地文件\n    READ_LOCAL_REPO_INFO_FILE: 'read-repo-info-file' // 读取存储在本地的仓库的信息\n}\n```\n\n这样借鉴了 web 中前后端分离的思想，个人认为可以很清晰的分离应用的逻辑。\n\n本文的素材源自个人的 Electron 小项目：[github-repo-viewer](https://user-gold-cdn.xitu.io/2019/8/24/16cc1d78c4abf8fe)","lastModified":"2019/12/27 下午10:10:25","tags":["Node","原创","Electron"]}