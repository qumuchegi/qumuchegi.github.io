{"title":"Node 流","content":"## 1. 什么是流？\n\n![image](/imgs_from_article/1577278373452__article-img__7EE40F5E-A6F9-4AD1-93A8-C2B533F54B9A_4_5005_c.jpeg)\n\n流是数据的集合 —— 就像数组或字符串一样。区别在于流中的数据可能不会立刻就全部可用，并且你无需一次性地把这些数据全部放入内存。这使得流在操作大量数据或是数据从外部来源逐段发送过来的时候变得非常有用。\n\n不同于缓冲，流可以读取数据的一部分同时立即提供给后序处理，这提高了内存的空间效率和程序运行的时间效率。\n\n    缓冲的内存空间问题：缓冲是一次性读取所有数据到内存，然后才能交给处理程序，如果文件数据过大比如由几百MB甚至几百GB，那么读取整个文件到缓冲，然后再一次下返回，那么可能会导致内存溢出（比如说在 V8 的缓存区不能超过1GB）。\n\n    缓冲的运行时间问题：只有在文件数据被完整读取到内存才能进行后续处理，比如说 如果使用同步读取的方法读取一个文件，当文件过大就会阻塞程序运行，虽然使用异步方法读取文件不会阻塞，但是仍然会把文件整个读到内存中。\n\n**使用流可以缓解缓冲的以上问题**：流可以实现一些无法通过缓存数据并一次性处理来实现的功能（比如在处理大文件压缩时，压缩之前要先读取文件，而文件太大，内存会溢出，如果使用流，那么可以通过流的管道在读文件的同时对流中的数据块进行压缩），除了避免内存溢出的空间问题，流还允许一旦读到文件的数据块就可以尽快处理数据，这比缓冲一次性读取整个文件再进行处理执行的速度会更快。\n\n\n## 2. 流的分类\n\n\n\n## 3. 流的特点\n\n1. **组合性** ：\n\n   流还可以通过管道 `pipe()` 组合起来，管道中的每个独立单元只实现单一的功能，（像中间件？），管道中的上一个处理单元的输出流作为下一个单元的输入，前提是管道中的下一个流必须支持上一个流的输出数据类型。流的可组合性不仅使流可以用来处理前面的纯 I/O 问题，也可以用来对代码进行 简化 和 模块化处理。使用 `pipe()` 还可以避免手动解决背压问题，因为管道会自动处理。\n\n2. **流的操作模式** :\n\n    流的操作模式有 *对象模式* 和 *二进制模式* 。\n    当创建流时，可以使用 objectMode 选项把流实例切换到对象模式。在该模式下，流中的数据可以看作是一系列独立的对象，通过设置 objectMode 参数使得流可以接受任何 JavaScript 对象。\n    在二进制模式下，流中的数据是以块的形式存在的，比如缓冲或者字符串.\n\n3. **流的背压** ：\n\n    在可读流中，数据写入缓冲的速度大于被读出的速度，那么缓冲会积聚大量数据，占用大量的内存。如果使用管道pipe（）方法，那么不用自己解决背压问题。\n\n## 4. 使用流：\n\n首先要创建流，可以使用 Node 内置的的流接口，也可以通过继承创建新的流类，或者直接使用第三方模块。\n\n\n\n## 5. 流的使用场景：\n\n### (1)处理I/O：\n\n        比如使用流对读入数据立即进行压缩和发送，不用等待所有数据读入缓存之后才能压缩和发送。\n        利用流的可组合性使用管道对数据进行各种变化，不仅是压缩还可以加密。\n\n### (2)使用流进行流程控制：\n\n        如顺序执行、无序并行执行、无序有限制的并行执行、顺序并行执行。\n\n**a. 顺序执行**：\n>比如将几个文件的内容拼接起来，要遵循文件的先后顺序，首先定义一个目标文件流，用 from2-array 这个模块创建一个文件数组，然后使用管道pipe（），在pipe（）中把每一个文件以流的模式读入，并且用读入目标文件流的管道中，将每一个文件按先后顺序依次读入目标文件流，就把所有文件拼接起来了。代码：\n```js\nfunction concatFiles(destination,files,callback){\n    const destStream = fs.createWriteStream(destination);\n    fromArray.obj(files)\n         .pipe(through.obj( ( file, enc, done ) => {\n             const src = fs.createReadStream(file);\n             src.pipe(destStream, {end:false});\n             src.on('end', done)\n         }));\n}\n    module.exports = concatFiles\n```\n在 concat.js 使用此模块：\n```js\n// concat.js:\nconst concatFiles = require('./concatFiles');\nconcatFiles(process.argv[2], process.argv.slice(3), ()=>{\n    console.log('文件成功连接！！')\n})\n\n```\n运行 `node concat allTogether.txt file1.txt file2.txt`\n\n将 file1.txt 、file2.txt 两个文件的内容拼接然后输入到 allTogether.txt 里。\n\n**b. 无序并行执行**：\n>充分利用 Node.js 的并发性，在两个数据块之间没有联系时，用并列执行来提高处理速度。比如有一个文件 urlList.txt, 里面的文本是每行一个URL，现在用流的方式并行读入这些URL 来做一些处理。\n\n定义一个并行执行的变换流类 ：\n```js\nconst stream = require('stream');\n\nclass ParallelStream extends stream.Transform {\n    constructor(userTransform){\n        super({objectMode:true});\n        this.userTransform = userTransform;\n        this.running = 0;\n        this.terminateCallback = null;\n    }\n\n    _transform(chunk, enc, done){\n        this.running++;\n        this.userTransform( chunk, enc, this.push.bind(this),\n            this._onComplete.bind(this));\n        done()\n    }\n\n    _flush(done){\n        if(this.running > 0){\n            this.terminateCallback = done;\n        }else{\n            done();\n        }\n    }\n    \n    _onComplete(err){\n        this.running--;\n        if(err){\n            return this.emit('error',err);\n        }\n        if(this.running === 0){\n            this.terminateCallback && this.terminateCallback()\n        }\n    }\n}\n\n```\n在上面创建的变换类中，默认使用对象模式，_transform() 方法会执行传入的变换函数，而且为了实现并行，在变换函数为执行完之前调用 done() 方法，变换函数中会绑定一个回调函数 _onComplete() ；流终止时会调用 _flush() 方法，只要还有任务在运行中，就不调用done()（done 的作用是每一个流的块完成之后才能处理下一个流，是一个流的原生API），而是将 done 赋值给 termnateCallback(), 赋值这个操作延迟了 done（）执行， 也就可以延迟 finish 事件触发；_onComplete() 方法在每一个异步任务完成后执行， 当所有任务完成后就调用 termnateCallback() 也就是 done() , 并且触发 finish 事件，执行 _flush() .\n\t\t\t\t\n使用这个类：checkUrls.js:\n\n```js\nconst fs = require('fs');\nconst split = require('split');\nconst request = require('request');\nconst ParallelStream = require('./parallelStream');\n\nfs.createReadStream(process.argv[2])\n    .pipe(split())\n    .pipe(new ParallelStream(( url, enc, push, done) => {\n        if(!url) return done();\n        request.head(url ,(err, respond)=>{\n            push(url + 'is' + (err ? 'down' : 'up') + '\\n');\n            done()\n        })\n    }))\n    .pipe(fs.createWriteStream('result.txt'))\n    .on('finish', ()=> console.log(' 所有 URL 已经校验'))\n```\n\n运行 `node checkUrls urlList.txt`","lastModified":"2019/12/25 下午8:53:17","tags":["Node"]}