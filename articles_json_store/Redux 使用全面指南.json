{"title":"Redux 使用全面指南","content":"![image](/imgs_from_article/1578139144930__article-img__redux.png)\n\n*参考*\n- Redux官网： https://redux.js.org/\n- 中文GitBook：https://cn.redux.js.org/\n\n>Redux 是除了 Facebook 的 Flux 之外另一个 flux 模式的实现。\n\n### 1. Redux的动机、作用：\n\t\n管理变化的应用状态 State，包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。\n\t\n使用Redux解决的痛点是：\n\t\n- 第1 ---在React里原来要求数据只能通过 props 层层传递到它被需要的组件，中间会经过一些并不需要这些数据的组件造成编程的困难，在使用 Redux 后可以做到数据只传给它被需要的组件；\n\n- 第2 ---在视图之间缓存数据，使下一次访问同一个视图时更快；\n\n- 第3 ---Redux 也是前端的一种项目架构方式，如同 web MVC、MVVM 一样，都是项目工程化的思维\n\n### 2. 三大原则：\n\t\n- （1）`单一数据源`（一个Redux应用只有一个store），也是单向的数据流；\n\t\n- （2）`state 只读`（唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象）；\n\n- （3）使用 `纯函数`（reducer）来修改state。\n\n### 3. 使用Redux的基本用法概念\n\n#### 3.1 Action\n\n>是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。\n\t\t\n`action 对象` 可以通过 `action 创建函数` 来生成，action创建函数 可以是一个异步非纯函数，把 action 创建函数组合进异步控制流，用来处理 AJAX 响应。\n\n**同步action和异步action**：\n\n>在 Redux 里，action 被 dispatch 出去后立即调用 reducer 来计算出新 state 就是同步 action；如果 action 被 dispatch出去后，过一段时间才执行 reducer 就是异步 action 。要允许 Redux 异步的执行 reducer，就需要使用 Redux 中间件（如 redux-thunk 等），因为 Redux 中间件（和 express 中间件有差别，在express里中间件指的是在接受请求和发送响应之间的代码）在  dispatch 一个action  和 reducer之间处理 action，可以有多个中间件来顺次处理这个 action，最后才传递到 reducer 里。Redux提供了专门的 `applyMeddleware()` 来传入中间件。applyMeddleware() 将会传入 `createStore()` 的第二个参数。\n\n#### 3.2 Reducer : Reducer<S, A> = (state: S, action: A) => S\n\n> Reducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，action只是描述了store 将如何变化以及负载了到达store数据，如何根据action来改变store要靠reducer来实现。要求Reducer要是纯函数，不能有副作用，没有 API 请求、没有变量修改，单纯执行计算。\n\nreducer 会接受两个参数，分别是之前的 state，和传入的 action ，reducer 会根据 action 的type 来执行对应的操作最后返回新的state。\n\n**注意**，在reducer里面不能直接修改 state，而是应该返回新的 state，可以用合并对象的方法 `Object.assing({},…,…)`, 且里面第一个必须是空对象， 不能这样:  `Object.assing(state，…)` 。也可以使用ES7语法对象展 { ...state, ...newState }。而在 default 情况下返回旧的 state。\n\n#### 3.3 store\n\nstore 提供 `dispatch（）` 用于分发 action 到 reducer 来更新 state。\n\nStore 有以下职责：\n\n- 维持应用的 state；\n- 提供 getState() 方法获取 state；\n- 提供 dispatch(action) 方法更新 state；\n```\t\t\t\t\t\ntype BaseDispatch = (a: Action) => Action\n```\n```\ntype Dispatch = (a: Action | AsyncAction) => any\n```\t\t\t\t\n- 通过 subscribe(listener) 注册监听器;\n- 通过 subscribe(listener) 返回的函数注销监听器。\n\t\t\n应用有多个 state，但是在 redux 里面不能创建多个 store，所以要组合多个 reducer。因为 reducer 的结果其实就代表了 store 的每一个部分，多个 reducer 最终组成了一个单一数据源store， 可以使用 `combineReducers()` 将多个 reducer 合并成为一个，最后传入store的 createStore()，创建唯一的store。 \n\n`subscribe(listener)`  监听器里面调用 getState() 来获取 state，监听到 state 变化时可以更新UI（如果使用React-redux绑定库就不用关注 subscribe(listener) 监听器。可以使用 `React-redux` 提供的 `connect()`，传入 mapStateToProps 和 mapDispatchToProps、UI组件来返回容器组件来绑定state和更新state的操作）\n\n>注意：在组件卸载之前我们必须调用 `subscribe(listener) ` 返回的函数，取消对 Redux store 的监听，否则会导致内存泄漏。\n\n### 4.  Redux 中间件 meddleware 和 Store 增强器\n\n#### 4.1 中间件 提供的是位于 action 被发起之后，到达 reducer 之前的扩展点。 middleware 可以完成包括异步 API 调用在内的各种事情。可以自己定义中间件，也可以使用第三方的中间件（Redux-thunk、Redux-saga）。 \n\n>Middleware 是一个组合 dispatch function 的高阶函数，返回一个新的 dispatch function，通常将异步 actions 转换成 action。Middleware 利用复合函数使其可以组合其他函数，可用于记录 action 日志、产生其他诸如变化路由的副作用，或将异步的 API 调用变为一组同步的 action。\n\t\t\n>中间件是使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。Middleware 可以让你包装 store 的 dispatch 方法来达到你想要的目的。同时， middleware 还拥有“可组合”这一关键特性。多个 middleware 可以被组合到一起使用，形成 middleware 链。其中，每个 middleware 都不需要关心链中它前后的 middleware 的任何信息。\n\t\t\nMiddleware 最常见的使用场景是无需引用大量代码或依赖类似 Rx 的第三方库实现异步 actions。这种方式可以让你像 dispatch 一般的 actions 那样 dispatch 异步 actions。例如，redux-thunk 支持 dispatch function，以此让 action creator 控制反转。被 dispatch 的 function 会接收 dispatch 作为参数，并且可以异步调用它。这类的 function 就称为 thunk。另一个 middleware 的示例是 redux-promise。它支持 dispatch 一个异步的 Promise action，并且在 Promise resolve 后可以 dispatch 一个普通的 action。\n\t\t\nMiddleware 并不需要和 createStore 绑在一起使用，也不是 Redux 架构的基础组成部分，但它带来的益处让我们认为有必要在 Redux 核心中包含对它的支持。因此，虽然不同的 middleware 可能在易用性和用法上有所不同，它仍被作为扩展 dispatch 的唯一标准的方式。\n\t\t\n#### 4.2  Store 增强器 `Store enhancer`  是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。\n\n### 5. Redux API\n\t\n#### 5.1 createStore( reducer, [ preloadedState ], enhancer )\n\n创建一个 Redux store 来以存放应用中所有的 state。\n\n参数：\n- `reducer (Function)` :  接收两个参数，分别是当前的 state 树和要处理的 action，返回新的 state 树。\n\t\t\n- `[preloadedState] (any)` :  初始时的 state。 在同构应用中，你可以决定是否把服务端传来的 state 水合（hydrate）后传给它，或者从之前保存的用户会话中恢复一个传给它。如果你使用 combineReducers创建 reducer，它必须是一个普通对象，与传入的 keys 保持同样的结构。否则，你可以自由传入任何 reducer 可理解的内容。\n\t\t\n- `enhancer (Function)` :  Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。要使用多个 store 增强器的时候，你可能需要使用 compose。***Redux 里附带的唯一的 store 增强器是  applyMiddleware()***。\n\t\t\n\n     \n#### 5.2 Store 方法\n\n- `getState()` 返回应用当前的 state 树。\n\t\t\n-  `dispatch(action)` 分发 action。这是触发 state 变化的惟一途径。\n\t\t\n-  `subscribe(listener)` 添加一个变化监听器。可以在变化监听器里面进行 dispatch()，可以在回调函数里调用 getState() 来拿到当前 state。这是一个底层 API。多数情况下，你不会直接使用它，会使用一些 React（或其它库）的绑定。\n\t\t\n  **subscribe(listener) 参数** ：\n\n     `listener (Function)` : 这是每当 dispatch action 的时候都会执行的回调。state 树中的一部分可能已经变化。你可以在回调函数里调用 getState() 来拿到当前 state。store 的 reducer 应该是纯函数，因此你可能需要对 state 树中的引用做深度比较来确定它的值是否有变化。\n\t\t\n  **subscribe(listener) 返回值**：\n\n     (Function) :  一个可以解绑变化监听器的函数。解绑方法是调用执行返回的函数。\n\t\t\t\n- `replaceReducer(nextReducer)`：替换 store 当前用来计算 state 的 reducer。\n>这是一个高级 API。只有在你需要实现代码分隔，而且需要立即加载一些 reducer 的时候才可能会用到它。在实现 Redux 热加载机制的时候也可能会用到。\n\t\n   **replaceReducer( nextReducer )参数**：nextReducer (Function)， store 会使用的下一个 reducer。\n\t\t\t\n#### 5.3 combineReducers(reducers)\n\nRedux 不是多个 store ，而一个使用多个 reducer 最后合并起来。将 reducer 函数 拆分成多个单独的函数，拆分后的每个函数负责独立管理 state 的一部分。`combineReducers` 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore 方法。\n\t\n由 `combineReducers()` 返回的 state 对象，***会将传入的每个 reducer 返回的 state 按其传递给 combineReducers() 时对应的 key 进行命名***。因此我们在store中获取某一个state时就应该用对于 reducer 的名字。\n\t\t\n>本方法只是起辅助作用！你可以自行实现不同功能的 combineReducers，甚至像实现其它函数一样，明确地写一个根 reducer 函数，用它把子 reducer 手动组装成 state 对象。\n\n> 在 reducer 层级的任何一级都可以调用 combineReducers。并不是一定要在最外层。实际上，你可以把一些复杂的子 reducer 拆分成单独的孙子级 reducer，甚至更多层。\n\t\t\n#### 5.4 applyMiddleware(...middleware)\n\nmiddleware 的函数签名是 `({ getState, dispatch }) => next => action`\n     \n**参数**：\n\n- `...middleware (arguments) 中间件`\n\n>遵循 Redux middleware API 的函数。每个 middleware 接受 Store的 dispatch 和 getState 函数作为命名参数，并返回一个函数。该函数会被传入被称为 next 的下一个 middleware 的 dispatch 方法，并返回一个接收 action 的新函数，这个函数可以直接调用 next(action)，或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个 middleware 会接受真实的 store 的 dispatch 方法作为 next 参数，并借此结束调用链。所以，middleware 的函数签名是 ({ getState, dispatch }) => next => action。\n\t\n**返回值**：\n\t\t\n- (Function) 一个应用了 middleware 后的 store enhancer。这个 store enhancer 的签名是 createStore => createStore，但是最简单的使用方法就是直接作为最后一个 enhancer 参数传递给 createStore() 函数。\n\t\t\n中间件如 Redux-thunk 的全部代码：\n```js\n\t\tfunction createThunkMiddleware(extraArgument) {\n\t\t\treturn ({ dispatch, getState }) => next => action => {\n\t\t\t\tif (typeof action === 'function') {\n\t\t\t\t\treturn action(dispatch, getState, extraArgument);\n\t\t\t\t}\n\t\t\t\treturn next(action);\n\t\t\t};\n\t\t}\n\t\t\n\t\tconst thunk = createThunkMiddleware();\n\t\tthunk.withExtraArgument = createThunkMiddleware;\n\t\t\n\t\texport default thunk;\n\t\n```\t\n#### 5.5  `bindActionCreators(actionCreators, dispatch)` ：\n\n把一个 value 为不同 action creator 的对象，转成拥有同名 key 的对象。同时使用 dispatch 对每个 action creator 进行包装，以便可以直接调用它们。惟一会使用到 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 dispatch 或 Redux store 传给它。\n\t\n#### 5.6 `compose(...functions)`：\n\n这个方法从右到左来组合多个函数。这是函数式编程中的方法，为了方便，被放到了 Redux 里。当需要把多个 store 增强器 依次执行的时候，需要用到它。\n\t\n**参数**：\n\n- (arguments):  需要合成的多个函数。预计每个函数都接收一个参数。它的返回值将作为一个参数提供给它左边的函数，以此类推。例外是最右边的参数可以接受多个参数，因为它将为由此产生的函数提供签名。（译者注：compose(funcA, funcB, funcC) 形象为 compose(funcA(funcB(funcC())))）\n\t\n**返回值**：\n\t\t\n- (Function): 从右到左把接收到的函数合成后的最终函数。\n\n### 6. React-redux：是一个Redux的React绑定库。它的API只有\n\t\n#### 6.1  `<Provider store>`\n\t\t\t\n<Provider store> 使组件层级中的 connect() 方法都能够获得 Redux store。正常情况下，你的根组件应该嵌套在 <Provider> 中才能使用 connect() 方法。\n\t\t\t\t\n#### 6.2 `connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])`\n\t\t\t\n连接 React 组件与 Redux store。\n\n连接操作不会改变原来的组件类。\n\n反而返回一个新的已与 Redux store 连接的组件类（容器组件）。\n\t\t\t\t\n**参数**：\n\t\t\t\t\n- `[mapStateToProps(state, [ownProps]): stateProps] (Function)`: \n\n   如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。如果你省略了这个参数，你的组件将不会监听 Redux store。如果指定了该回调函数中的第二个参数 ownProps，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，mapStateToProps 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。\n\t\t\t        \n\n- `[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function)`:\n\n  如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，对象所定义的方法名将作为属性名；每个方法将返回一个新的函数，函数中dispatch方法会将 action creator 的返回值作为参数执行。这些属性会被合并到组件的 props 中。\n\t\t\t\t\n   如果传递的是一个函数，该函数将接收一个 dispatch 函数，然后由你来决定如何返回一个对象，这个对象通过 dispatch 函数与 action creator 以某种方式绑定在一起（提示：你也许会用到 Redux 的辅助函数 bindActionCreators()。如果你省略这个 mapDispatchToProps 参数，默认情况下，dispatch 会注入到你的组件 props 中。如果指定了该回调函数中第二个参数 ownProps，该参数的值为传递到组件的 props，而且只要组件接收到新 props，mapDispatchToProps 也会被调用。\n\t\t\t\t\n\n- `[mergeProps(stateProps, dispatchProps, ownProps): props] (Function)`:\n  \n 如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的 props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。你也许可以用这个回调函数，根据组件的 props 来筛选部分的 state 数据，或者把 props 中的某个特定变量与 action creator 绑定在一起。如果你省略这个参数，默认情况下返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。\n\t\t\t\t\n\n- `[options] (Object)` 如果指定这个参数，可以定制 connector 的行为：\n\t\t\t\t\t\n    [pure = true] (Boolean): 如果为 true，connector 将执行 shouldComponentUpdate 并且浅对比 mergeProps 的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或 state 而只依赖于 props 和 Redux store 的 state。默认值为 true。\n\n    [withRef = false] (Boolean): 如果为 true，connector 会保存一个对被被包含的组件实例的引用，该引用通过 getWrappedInstance() 方法获得。默认值为 false。\n\n \n\n\n","lastModified":"2020/1/4 下午7:59:24","tags":["原创","前端","javascript","React","Redux"]}