{"title":"深入浅出 webpack","content":">简要记录一下 webpack 的知识结构。参考《深入浅出 webpack》 这本书\n\n### 1. 什么是构建，为什么需要构建工具？\n\n构建就是做这件事情，将源代码转换成可执行的 JavaScript、CSS、HTML 代码，包括如下内容。\n\n- **代码转换**：将 TypeScript 编译成 JavaScript、将 SCSS 编译成 CSS 等。\n\t\t\n- **文件优化**：压缩JavaScript、CSS、HTML代码，压缩合并图片等。\n\t\t\n- **代码分割**：提取多个页面的公共代码，提取首屏不需要执行部分的代码让其异步加载。\n\t\t\n- **模块合并**：在采用模块化的项目里会有很多个模块和文件，需要通过构建功能将模块分类合并成一个文件。\n\t\t\n- **自动刷新**：监听本地源代码的变化，自动重新构建、刷新浏览器。\n\t\t\n- **代码校验**：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。\n\t\t\n- **自动发布**：更新代码后，自动构建出线上发布代码并传输给发布系统。\n\t\n构建其实是工程化、自动化思想在前端开发中的体现，将一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。构建为前端开发注入了更大的活力，解放了我们的生产力。\n\n### 2. 有哪些构建工具？\n\n#### 2.1  npm 脚本\n\nnpm script 是 在 package.json 文件里使用 scripts 字段定义的任务，每个 scripts 字段对应一段 shell 脚本，底层通过 shell 去运行脚本命令。npm script 缺点就是任务过于简单。\n\t\n在 Grunt 和 Gulp 中可以将一些任务组合起来成为一个新的命令，尤其是在构建或测试时非常实用 在 npm 中有两种方式可以解这个问题：一是通过 pre- 和 post- 钩子，如果在执行某个任务之前需要执行某个任务（如压缩之前合并文件），这是个不错的选择；另外你还可以实用 && 这个命令连接符：\n\n```js\n\"devDependencies\": {\n  \"jshint\": \"latest\",\n  \"stylus\": \"latest\",\n  \"browserify\": \"latest\"\n},\n\"scripts\": {\n   \"lint\": \"jshint **\",\n   \"build:css\": \"stylus assets/styles/main.styl > dist/main.css\",\n   \"build:js\": \"browserify assets/scripts/main.js > dist/main.js\",\n   \"build\": \"npm run build:css && npm run build:js\",\n   \"prebuild:js\": \"npm run lint\"\n}\n```\n\n现在只需执行 `npm run build`, 上述脚步命令任务的执行顺序就是：先 `npm run lint`，再 build，build 包括 build:css 和 build:js 两个任务。这样就实现了多任务执行。\n\n##### 2.2  webpack: 一切皆模块。\n##### 2.3 Grunt\n##### 2.4 Gulp\n##### 2.5 Fis3\n##### 2.6 Rollup：功能不够完善。\n\n### 3. webpack 配置选项（部分）\n\n-   **context** :  webpack 在寻找相对路径的文件时以 context 为根目录，如果没有配置 context，那么默认的根目录为 启动webpack 时所在的当前目录。如果配置 context，那么其值应为一个绝对路径。\n\t\t\n- **Entry** 入口：有 3 种类型值：string、array、object;\n\t\t\n- **output.filename** : 当需要输出多个构建结果 chunk 时，需要为每一个 chunk 取不同的名字，可以在 output.filename 的值种借助一些内置变量设置如 '[name].bundle.js'，内置变量有 id、name、hash、chunkhash\n\n内置变量 | 意义 \n:-: | :-: \nid | chunk 的唯一标识，从0开始\nname | Chunk 的名称\nhash | Chunk  的 Hash 值，长度可以指定如 [hash : 8]\nchunk hash| Chunk 内容的 Hash 值, 长度可以指定如 [chunkhash : 8]，需要注意在 ExtraTextWebpack 里使用的是 contenthash 而不是 chunkhash\n\n- **output.chunkFilename** : 与上面的 output.filename 类似，也支持相同的内置变量，但是 chunkfilename 只是用于指定在运行过程中生成的 Chunk 的名称，比如在使用 CommonsChunkPlugin 提取公共代码、使用 import 动态加载依赖（代码分割）等时候。\n\t\t\n- **output.publicPath** : 在复杂项目里需要将构建出来的资源异步加载，这些资源可以放在 CDN 上，这个时候需要用 publicPatch 来设置 CDN 上此构建结果资源的 URL，还需要在需要引入这个构建资源的 html 文件里配置 script ：`<script src=\"http://somecdn/bundle.js\"/>`，但是如果只有个别资源需要CDN，则可以在对应的 loader 配置中增加 publicPath。\n\t\t\n- **output** 的 **publicPath** 和 **path** 也可以设置内置变量, 不过只有 hash.\n\n-  **output.library** 和 **output.libraryTarget**、**output.libraryExport** : 用 webpack 构建一个可以被其他模块导入的库时，可以用 library 指定库的名字，libraryTarget 指定以何种方式导出库（比如以 var默认、commonjs2、this、等）\n\n libraryTarget 值 | 使用导出库的方法（假设库的名字 library=\"myLibrary\"） \n:-: | :-: \nvar  | myLibrary.dosomething()\ncommonjs | require('library-name-in-npm')['myLibrary'].dosomething()  ，library-name-in-npm 是指库被发布到 npm 时的名字\ncommonjs2 | require('library-name-in-npm').dosomething()，如果设置 libraryTarget 为 \ncommonjs2，那么设置 library 将没有意义\nthis | this.myLibrary.dosomething()\nwindo| window.myLibrary.dosomething()\nglobal| global.myLibrary.dosomething()\n\n- **output.librayExport** : 指定导出模块中哪些子模块需要被导出。\n\t\t\n- **loader** 可以以查询字符串的形式传入参数，比如 use : [ babel-loader ? ' cacheDirectory '], 其中 cacheDirectory 是传给 babel-loader 的参数，用于缓存 babel 的编译结果，加快重新编译的速度。\n\t\t\n-  **module.rules** 下每一个 loader 的 **parser** :  配置哪些模块语法被解析、哪些不被解析。\n\t\t\n- **module.noparse** :配置哪些文件不被解析。比如不用模块化标准的模块 jquery等不需要解析处理，以提高构建性能。\n\t\t\n- **resolve** 配置怎么寻找模块对应的文件:\n\nresolve 的部分子选项  | 作用\n:-: | :-: \nalias  | 将模块导入路径映射成别名\nmainFields | 有一些模块会对不同环境提供不同代码，mainFields 配置决定优先采用哪份代码\nextensions | 导入文件路径没有文件后缀时，自动带上此选项配置的后缀名\nmodules | 配置 webpack 去哪些目录下寻找第三方模块，默认是 node_modules\n\n- **DevServer**  默认使用http，如果必须使用 https （比如 http2 和 serveice worker 必须运行在 https 上）可以加入 https : true 字段，DevServer 会自动生成一份 https 证书。如果我们使用自己的证书可以在 DevServer 的 https 对象中加入 key、cert、ca 3个属性，分别指定证书的key、crt、pem 文件路径。\n\t\t\n- **externals**  配置哪些模块不用打包，这些模块是外部环境提供的， webpack 在打包时可以忽略它们，告诉 webpack 在 JavaScript 运行环境中已经内置了哪些全局变量，不用把这些全局变量打包到代码中而是直接使用它们。\n\n   externals 使用场景是：\n\t\n   1）比如一个 npm 组件包它需要React 这个库，如果这个包是计划用于 React 项目，那么在使用这个包的项目环境中就已经有了 React 了，所以组件包自己可以不用打包 React，此时可以使用 externals 来指定 React 是外部项目环境提供的，组件自己可以不用打包；\n\t\n  2）比如项目里面 React 可以使用 CDN 的方式引入，此时就不需要打包 React 了，可以使用 externals.\n\n### 4. 导出 webpack 配置：\n\n1）可以导出一个函数，函数接受 2 个参数 env 和 argv, env 对象 是 运行 webpack 的环境变量；\n\n2）导出一个 promise ；\n\n3）以数组形式导出多个配置对象。\n\n### 5. webpack 实战\n\n##### 5.1 在 webpack 项目中借助  Babel  来使用 ES6 语法和 React 的 JSX\n\n一个 JavaScript编译器，实现 ES6 ->ES5，将浏览器不支持的语法转换为浏览器支持的语法，需要项目根目录中有一个 .babelrc 文件来配置Babel 的编译规则（当然也有 babel.config.js），这是一个 JSON 格式的文件。.babelrc 的大致内容就是  plugins 和 presets .\n\t\t\n.babelrc：\n> { \n\"presets\": [...], \n\"plugins\": [...] \n}\n\t\t\nplugins : 告诉 babel 要使用哪些插件，插件可以控制如何转化代码。插件需要我们自己用npm install 安装 ，比如 babel/plugin-transfrom-runtime 插件。Babel 插件列表。\n\t\t\t\npresets : 告诉 Babel 要转化的源码使用了哪些新的语法特性，presets 有 env、stage-0/1/2/3、flow、react、typescript、minify.\n\t\t\n**如何在 webpack 中使用 Babel**：由于 Babel 做的就是转化代码，所以在 webpack 中应该以 loader 来使用 Babel，首先在项目里下载安装 `@babel/core`、`babel-loader`、`@babel/preset-env` , 然后在 webpack 配置文件里 对需要转换的 js 文件使用 babel-loader 即可，@babel/prsent-env 是babel官方的预置器，可以根据用户设置的目标环境自动添加所需的插件和补丁来编译ES6+ 代码。如果项目是 React 应用，除了转换 ES6 的 Class 语法，还需要另下载 @babel/preset-react 用来转换 React 中的 JSX，并且在**.babelrc** 文件中配置 React preset:\n\t\t\n>\"preset\":[\"react\"]\n\t\t\t\t\n也可以在 webpack 的配置文件里在使用 babel-loader 处理 JS 文件时，使用 options 属性配置 babel 插件和预置：\n\n```js\n{\n\t   test: /\\.js$/,\n\t   include: path.resolve(__dirname, 'admin-server/assets/src/js'),\n\t   //exclude: /node_modules/,\n\t   use: {\n\t\tloader: 'babel-loader',\n\t\toptions: {\n\t\t   presets: ['@babel/preset-env', '@babel/preset-react'],\n\t\t   plugins: [[\"@babel/plugin-transform-runtime\",{ // 为了 babel 不把 async 转化为 generator 要引入这个 babel 插件\n\t\t     \"absoluteRuntime\": false,\n\t\t     \"corejs\": false,\n\t\t     \"helpers\": true,\n\t\t     \"regenerator\": true,\n\t\t     \"useESModules\": false,\n\t\t     \"version\": \"7.0.0-beta.0\"\n\t\t   }]]\n\t\t }\n\t}\n},\n\t\t\n```\n\n##### 5.2 构建 React 同构应用\n\n即从一份代码构建出两份 JavaScript代码，一份在浏览器运行，一份在服务端 Node 环境运行并渲染出 HTML。同构应用的目的也就是服务端渲染的目的，就是要加快应用首屏渲染，还有方便搜索引擎抓取。\n\n**step 1**: 构建浏览器端代码的 webpack 配置省略，关键在于构建 Node 端渲染HTML的代码的 webpack 配置：\n\n![image](/imgs_from_article/1578020504892__article-img__React同构.JPG)\n\n上面服务端构建配置的几个关键：\n\n\t1）target：构建目标设置为 node ；\n\t2）externals：[nodeExternals()]防止 node-modules 下的第三方模块被打包进去，因为 node 会默认到  node-modules  下寻找和使用第三方模块；\n\t3）loader 中忽略 CSS 文件，因为 计算 CSS 会影响服务端的渲染性能；\n\t4）libraryTarget：‘commonjs2'，以 commonjs2 规范导出渲染函数，以供用 node 编写的 HTTP 服务器代码调用。\n\t\t\n**step2** : 现在编写两份代码 React 代码，\n\t\t\n\ti. 一份用于在浏览器端渲染 React 组件：\n\t\t\n\t\tReactDOM.render(<APP/>,document.getElementById('root'))\n\t\t\t\n\tii. 另一份导出的是 用于在Node服务端渲染HTML字符串的 渲染函数 render：\n\t\t\n\t\timport { renderToString } from 'react-dom/server'\n\t\t\t\n\t\texport function render(){\n\t\t\t return renderToString(<APP/>)\n\t\t}\n\t\t\t\n\t   然后服务端只要引入 render 并在 html 模版中调用即可：\n\t\t\n\t\tres.send('<html>\n\t\t\t\n\t\t……\n\t\t<div>${render( )}</div>\n\t\t\t\n\t\t……\n\t\t</html>')\n\t\t\n**step3** : 运行 两个 webpack 命令 ，一个是用于构建浏览器端代码的命令，另一个是构建服务端渲染函数代码的命令。然后就可以了。现在前端请求页面就是后端渲染好的HTMl字符串的结果。\n\n\n##### 5.3 构建 npm 模块 \n\nwebpack 不仅可以用于构建可运行的应用，也可以构建可上传到 npm 的模块。下面以构建一个上传到 npm 的 React 组件为例, 要求如下：\n\n- 源代码采用 ES6 编写，单发布到 npm 仓库时需要转换为 ES5 代码，并且遵守 CommonJS 模块化规范。如果发布到 npm 上的 ES5 代码是经过转换的，则请同时提供 Source Map 以方便调试。\n\n- 如果是打包 UI 组件模块，那么其依赖的其他资源文件如 CSS 文件也需要包含在发布的模块里。\n\n- 尽量减少冗余代码，减小发布后的包的大小。\n\n- 在发布出去的组件的代码中不能含有其依赖的模块的代码，而是让用户可选择性的安装，防止用户重复安装依赖包。\n\n首先看看最终要上传的模块的目录结构：\n\t\t\n\t\t\t\tnode_modules/hello-webapck\n\t\t\t\t|---lib\n\t\t\t\t|    |----index.css（组件所有依赖的 CSS）\n\t\t\t\t|    |----index.css.map\n\t\t\t\t|    |----index.js （符合 commonjs 规范的 ES5 代码）\n\t\t\t\t|    |----index.js.map\n\t\t\t\t|---src（ES5源码）\n\t\t\t\t|     |----index.css\n\t\t\t\t|     |----index.js\n\t\t\t\t|____package.json（模块描述文件）\n\t\t\t\t\n从 npm 下载这个模块之后可以这样引入和使用：\n\t\t\nES6 方式引入：\n```js\n\timport HelloWebpack from ‘hello-webpack'\n\timport 'hello-webpack/lib/index/css'\n```\t\n或者 ES5 方式引入：\n```js\n        var HelloWebpack = require（\"hello-webpack\")\n\trequire('hello-webpack/lib/index/css')\n```\t\t\n使用渲染：\n```js\t\n\trender（<HelloWebpack/>）\n```\t\n现在来开始编写、构建并发布此模块：\n\t\t\n**step1**: 从初始化模块项目目录开始，新建一个文件夹并 npm init，就自动创建了一个 package.json 模块描述文件。然后编写好 src 目录下的模块源码，包括 CSS 和 JS 。\n\t\t\n**step2**: 配置 webpack 构建规则：\n\n\n![image](/imgs_from_article/1578021225893__article-img__webpack打包模块.png)\n\n之后运行 webpack 构建即可。\n\t\t\t\n有必要说明一下以上的 webpack 配置文件是如何对应上面的4个要求的：\n\t\t\t\t\t\n- i. 对于要求 1，使用 babel-loader 将 ES6 转化为 ES5，devtool:'source-map'提供 source-map 发布调试，output.libraryTarget='commonjs2'，使输出的代码符合 Commonjs2 模块化规范，以供其他模块导入使用。\n\t\t\t\t\t\n- ii. 对于要求2，使用 css-loader （css-loader 解释(interpret) @import 和 url() ，会 import/require() 后再解析(resolve)它们）和 extra-text-webpack-plugin（提取 CSS为单独文件）\n\t\t\t\t\t\n- iii. 对于要求3，Babel 在将 ES6 转化为 ES5 后会注入一些辅助函数，比如 ES6 的 class转化为 ES5  需要 2 个辅助函数，Babel 会在每个输出文件中内嵌这些辅助函数，造成代码冗余。为了防止这些辅助函数的代码在模块被多次引入时重复出现造成代码冗余，可以用 require 的方式引入，这样就可以让辅助函数只出现一次。此时就可以使用 babel-plugin-transform-runtime 这个 Babel 插件，下载安装 babel-plugin-transform-runtime 和 babel-runtime 这两个 Babel 插件在 .babelrc 文件的 plugins 中加入：\n```js\u000b\n  [\n      \"transform-runtime\",\n      {\n\t\"helpers\": false,\n\t\"polyfill\": false,\n\t\"regenerator\": true,\n\t\"moduleName\": \"babel-runtime\"\n      }\n]\n```\n\t\t\t\t\t\t\t\t\t\n- iv. 对于要求4，需要 webpack 配置 externals ，从构建中排除哪些不需要打包的模块，比如 react 和 babel-runtime .\n\n**step4** :  发布 构建好的 npm 模块。发布前需要正确配置 描述文件 package.json ：由于我们在上面构建出的代码 的入口文件为 ./lib/index.js，所以需要修改 package,json 中的 main 字段：\n```js\n\t\"main\" : \" lib/index.js\",\n\t\"jsnext:main\" : \"src/index.js\"\n```\n`\"jsnext:main\" : \"src/index.js\"`这一句用于指出 用 ES6 编写的模块入口文件所在的位置，便于实现 Tree Shaking\n\t\t\n最后在登录 npm 的情况下，只需 npm publish 即可将模块发布到 npm.\n\t\t\n⚠️⚠️⚠️注意：webpack 只适用于构建完整不可分割的 npm 模块。\n\n##### 5.4 构建离线应用 \n\n在此省略，但是原书此部分关于使用 service worker（是PWA的重要部分） 实现离线缓存应用和使用 webpack 构建离线应用的部分很有参考价值。可以看看原书。\n\t\t\n##### 5.5 加载图片\n\t\t\n- i. 使用 `file-loader` : 会将 JavaScript 文件和 CSS 文件 中的导入图片的语句替换为图片打包后的地址。\n\n- ii. 使用 `url-loader` : 会将图片的内容经过 base64 编码后注入到 javascript 或 CSS 中。这样做的好处是可以减少 HTTP 请求次数，在 HTTP1 中，如果是以地址形式加载的图片就会为每一个图片建立一次HTTP连接。但是图片太大的话采用注入图片内容的方式也会造成文件加载太慢，所以可以在使用 url-loader  的同时制定一个文件大小 limit , 超过 limit 是时通过 fallback 改用 file-loader:\n```js\n\t{\n\t\ttest: /\\.(woff|woff2|eot|ttf|otf)$/, //加载字体\n\t\tuse: [{\n\t\t\tloader:'url-loader',\n\t\t\toptions:{\n\t\t\tlimit:1024*30,\n\t\t\tfallback:'file-loader'\n\t\t      }]\n\t}\n```\n\t\t\t\t\t\n##### 5.6 加载 SVG\n加载 SVG 可以使用 file-loader、url-loader。也可以使. 用 raw-loader、svg-inline-loader.\n\t\n##### 5.7 通过 Node.js API 启动 Webpack\nwebpack 本身就是一个 Node.js 应用程序。可以在 Node 中调用 Webpack ，比直接使用 webpack 配置文件会更加灵活。\n\t\t\t\t\n##### 5.8 使用 webpack 结合 Typescript、SCSS、Vue 等省略\n\n实战总结（在项目中怎么用好 webpack ）\n实战难以覆盖所有的场景，我们实际使用中需要根据遇到的问题寻找对应的解决方法，可以根据一下思路：\n\n![image](/imgs_from_article/1578022213995__article-img__webpack使用思路.JPG)\n\n\n### 6 使用 webpack 优化开发体验和输出代码\n\n分为 优化开发体验（构建速度 + 自动化一些重复工作）和 优化输出（减少生产环境下的首屏加载时间 + 提升代码性能） 两个部分。\n\n##### 6.1 缩小文件的搜索范围\nwebpack 从入口出发递归解析导入语句，根据导入语句去寻找要导入的文件，然后根据要导入的文件的后缀使用配置中的 loader 去处理文件。如果项目太大要解析处理的文件变多，那么构建速度就会变慢，所以有必要加快文件搜索速度或者加快 loader 处理文件的速度，可以从以下几个方面来对此优化：\n\t\n- i. 优化 loader 配置：通过 test、include、exclude 3个配置项来命中 loader 要处理的文件，关键是要命中我们需要的文件，不能把我们不需要处理的文件也包括进去，此时可 配置 include 为我们源码文件夹，只处理这个文件夹里的文件，缩小了文件搜索的范围，也避免了一些不必要的文件处理。\n\t\t\t\n- ii. 优化 resolve.moudles 配置：配置 wbepack 去哪些目录寻找第三方模块。默认值是 [  'node_modules ' ], 即先去当前目录的 ./node_modules 里寻找第三方模块，找不到则去上一级再上一级。可以将其配置为绝对路径，这样就可以加快搜索速度。\n\t\t\t\n- iii. 优化 resolve.mainFields 配置：配置第三方模块使用哪个入口文件，比如 isomorphic-fetch 模块提供 浏览器和 node 端的代码，在浏览器端通过 fetch/XHR 实现，在 node 端通过 http 模块实现，在其 package.json 描述文件里：\n\n```js\n  {\n     \"browser\": \"fetch-npm-browserify.js\",\n     \"main\": \"fetch-npm-node.js\"\n  }\n```\n>为不同环境使用不同代码，为了减少搜索步骤，在明确第三方模块的入口文件描述字段时，可以设置的尽量少。由于大多数的算法模块都采用 main 字段描述入口位置，可以配置  resolve.mainFields 为 ['main']\n\t\t\t\n- iv. 优化 resolve.alias 配置：将导入语句原路径 映射成另一个 新的路径。 对于一些第三方模块提供 2 套代码，一套遵循 模块化，webpack 在打包时会递归解析依赖的几十个文件非常耗时，另一套将所有代码打包好放在 一个 min.js 中可以不用模块化而直接运行，此时我们可以利用   resolve.alias 直接将第三方模块的引入路径映射为这个 min.js 的路径，比如 react :\n\n```js\n   module.exports = {\n        resolve: {\n           // 使用 alias 将导入 React 的语句换成直接使用单独的、完整的 react.min.js 文件\n           // 减少耗时的递归解析操作\n           alias: {\n              'react': path.resolve(__dirname, './node_modules/react/dist/react.min.js')\n           }\n        }\n\n}\n\n```\n\n- v. 优化 `resolve.extension` 配置：尽可能少的配置后缀列表，并且在导入语句中加入后缀。\n\t\t\t\n- vi. 优化 `moduls.noParse` 配置：此配置用于忽略对一些没有模块化文件的递归解析处理，提高构建性能。比如 react.min.js 没有采用模块化，所以对它递归解析没有意义，在 noParse 中加入 react.min.js 排除。\n\n##### 6.2 使用 DllPlugin\n\n`DLLPlugin` 和 `DLLReferencePlugin` 用某种方法实现了拆分 bundles，同时还大大提升了构建的速度。\n\n这种方法的原理是，那些经常被复用而且不会改变的第三方模块（React、react-dom 等）不用重新编译，所以可以在第一次编译后放在动态链接库，之后每一次重新构建都不会再编译动态链接库的模块，而是直接使用里面的代码，所以减少了构建时间。\n\t\n`DLLPlugin`：这个插件是在一个额外的 独立的 webpack 设置（如 webpack.dll.config.js）中创建一个只有 dll 的 bundle(dll-only-bundle)。 这个插件会生成一个名为 manifest.json 的文件，这个文件是用来让 DLLReferencePlugin 映射到相关的依赖上去的。需要注意的是，在这个配置文件里，DllPlugin 中参数 name 值必须与 `output.library` 值保持一致，同时在 DllPlugin 的 path 参数定义输出 manifest.json 文件的输出路径。\n\nDllPlugin 的参数  | 含义\n:-: | :-: \ncontext (optional)  | manifest 文件中请求的上下文(context)(默认值为 webpack 的上下文(context))\nname | 暴露出的 DLL 的函数名 (TemplatePaths: [hash] & [name] )\npath | manifest json 文件的绝对路径 (输出文件)\n\n`DLLReferencePlugin`：这个插件是在 webpack 主配置文件中设置的， 这个插件把只有 dll 的 bundle(们)(dll-only-bundle(s)) 引用到需要的预编译的依赖。通过引用 dll 的 manifest 文件来把依赖的名称映射到模块的 id 上，之后再在需要的时候通过内置的 __webpack_require__ 函数来 require 他们\n\nDLLReferencePlugin 参数  | 含义\n:-: | :-: \ncontext  | (绝对路径) manifest (或者是内容属性)中请求的上下文\nmanifest | 包含 content 和 name 的对象，或者在编译时(compilation)的一个用于加载的 JSON manifest 绝对路径\ncontent (optional) | 请求到模块 id 的映射 (默认值为 manifest.content)\nname (optional) | dll 暴露的地方的名称 (默认值为 manifest.name) (可参考 externals)\nscope (optional) | dll 中内容的前缀\nsourceType (optional) | dll 是如何暴露的 (libraryTarget)\n\n`DllPlugin` 和 `DllReferencePlugin` 的用例：\n\n一个为 react、react-dom 、polyfill 构建动态链接库的例子：\n\t\n 1）用一个独立 webpack 配置构建出动态链接库文件 manifest.json:\n```js\n\t\twebpack_dll.config.js:\n\t\t\n\t\tconst path = require('path');\n\t\tconst DllPlugin = require('webpack/lib/DllPlugin');\n\t\tmodule.exports = {\n\t\t\t// JS 执行入口文件\n\t\t\tentry: {\n\t\t\t\t// 把 React 相关的放到一个单独的动态链接库\n\t\t\t\treact: ['react', 'react-dom'],\n\t\t\t\t// 把项目需要所有的 polyfill 放到一个单独的动态链接库\n\t\t\t\tpolyfill: ['core-js/fn/object/assign', 'core-js/fn/promise', 'whatwg-fetch'],\n\t\t\t},\n\t\t\toutput: {\n\t\t\t\t// 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，也就是 entry 中配置的 react 和 polyfill\n\t\t\t\tfilename: '[name].dll.js',\n\t\t\t\t// 输出的文件都放到 dist 目录下\n\t\t\t\tpath: path.resolve(__dirname, 'dist'),\n\t\t\t\t// 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react\n\t\t\t\t// 之所以在前面加上 _dll_ 是为了防止全局变量冲突\n\t\t\t\tlibrary: '_dll_[name]',\n\t\t\t},\n\t\t\tplugins: [\n\t\t\t\t// 接入 DllPlugin\n\t\t\t\tnew DllPlugin({\n\t\t\t\t// 动态链接库的全局变量名称，需要和 output.library 中保持一致\n\t\t\t\t// 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值\n\t\t\t\t// 例如 react.manifest.json 中就有 \"name\": \"_dll_react\"\n\t\t\t\tname: '_dll_[name]',\n\t\t\t\t// 描述动态链接库的 manifest.json 文件输出时的文件名称\n\t\t\t\tpath: path.join(__dirname, 'dist', '[name].manifest.json'),\n\t\t\t\t}),\n\t\t\t],\n\t\t};\n```\n⚠️注意：DllPlugin 打包好 React 之后要手动在 index.html 中引入打包好的 react.dll.js，否则源文件中引用 react 模块将引用不到。也可以使用 add-asset-html-webpack-plugin 这个插件将打包好的 react.dll.js 添加到 index.html.\n\t\t\n2）在主 webpack 配置中使用 manifest.json：\n```js\n\t\twebpack.config.js:\n\t\t\t\tconst path = require('path');\n\t\t\t\tconst DllReferencePlugin = require('webpack/lib/DllReferencePlugin');\n\t\t\t\tmodule.exports = {\n\t\t\t\t\tentry: {\n\t\t\t\t\t\t// 定义 入口 Chunk\n\t\t\t\t\t\tmain: './main.js'\n\t\t\t\t\t},\n\t\t\t\t\toutput: {\n\t\t\t\t\t\t// 输出文件的名称\n\t\t\t\t\t\tfilename: '[name].js',\n\t\t\t\t\t\t// 输出文件都放到 dist 目录下\n\t\t\t\t\t\tpath: path.resolve(__dirname, 'dist'),\n\t\t\t\t\t},\n\t\t\t\t\tmodule: {\n\t\t\t\t\t\trules: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// 项目源码使用了 ES6 和 JSX 语法，需要使用 babel-loader 转换\n\t\t\t\t\t\t\ttest: /\\.js$/,\n\t\t\t\t\t\t\tuse: ['babel-loader'],\n\t\t\t\t\t\t\texclude: path.resolve(__dirname, 'node_modules'),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tplugins: [\n\t\t\t\t\t\t// 告诉 Webpack 使用了哪些动态链接库\n\t\t\t\t\t\tnew DllReferencePlugin({\n\t\t\t\t\t\t\t// 描述 react 动态链接库的文件内容\n\t\t\t\t\t\t\tmanifest: require('./dist/react.manifest.json'),\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tnew DllReferencePlugin({\n\t\t\t\t\t\t\t// 描述 polyfill 动态链接库的文件内容\n\t\t\t\t\t\t\tmanifest: require('./dist/polyfill.manifest.json'),\n\t\t\t\t\t\t}),\n\t\t\t\t\t],\n\t\t\t\t\tdevtool: 'source-map'\n\t\t\t\t};\n\t\t\n```\n##### 6.3 使用 HappyPack 插件\n\nwebapck 在执行构建时最耗时的就是 loader 处理文件，因为这个过程涉及文件读写和计算密集的操作，而且 webpack 还运行在 单线程 的 Node 之上， webpack 一个一个的处理任务不能同时处理多个任务。为了发挥多核CPU的功能，提升构建速度，可以使用 HappyPack 的插件，其原理是把多个 loader 读写并处理文件 的任务分解到多个进程去并行处理，从而减少总的构建时间。需要下载安装这个插件，然后在 webpack.config.js 中将 loader 移到 HappyPack 实例中，由 HappyPack 来统一调度将其分配到多个子进程执行。例如一个使用 HappyPack 的 webpack 配置：\n\n![image](/imgs_from_article/1578023749291__article-img__Happypack.png)\n\nHappyPack 除了 id 和 loaders 2个参数 还有：threads、verbose、threadPool.\n\nHappyPack 参数 | 作用\n:-: | :-: \nthreads|代表开启几个子进程去处理这一类型的文件，默认为3\nverbose | 是否允许 HappyPack 输出日志\nthreadPool\t| 代表共享进程池，即多个 HappyPack 实例都使用同一个共享进程池中的子进程去处理任务，以防止资源占用过多\n\n##### 6.4 使用 ParrellelUglifyPlugin 插件\n\n不仅是上述 loader 读取处理文件会计算耗时，而且在构建生产版本代码时的压缩代码也会非常耗时（使用 UglifyJS 插件压缩JS代码时，需要先将代码解析成Object表示的 AST（抽象语法树），再去应用各种规则去分析和处理 AST，所以这个过程计算量大耗时较多。），所以有了 `webpack-parallel-uglify-plugin` 这个插件，其同样可以利用多进程并行处理的思想来压缩代码。webpack 原本会有多个JavaScript文件需要输出和压缩，使用 UglifyJS 去一个一个压缩再输出，所以会耗时，如果使用 `webpack-parallel-uglify-plugi` 就可以开启多个子进程，将多个文件的压缩工作分配给多个子进程去完成，每个子进程再通过 UglifyJS 压缩代码，但是是并行执行，所以可以更快的完成压缩工作。使用 webpack-parallel-uglify-plugi 只需下载这个插件后，将原来 webpack 配置中的 UglifyJsPlugin 去掉换成  ParrellelUglifyPlugin，其传入参数：\n\n![image](/imgs_from_article/1578024006302__article-img__parrellelUglifyPlugin.JPG)\n\n##### 6.5 使用自动刷新\n\n代码变动后自动重新构建并刷新浏览器。\n\t\t\n分为 文件监听、自动刷新浏览器 2 个步骤：\n\t           \n-  i. 文件监听并重新构建的工作 由 webpack 模块负责，需要配置:\n```js\n\twatch : true, // 开启文件监听并构建的功能\n\twatchOptions:{\n\t\t ignored: // 不需要监听的文件的路径,\n\t\t aggregateTimeout: // 监听到文件变化后 延迟构建 的时间，类似防抖，可以减少重新构建的频率，\n\t\t poll: // 每隔多少秒检查一次文件\n\t\t\t\t\n\t}\n```\n- ii. 自动刷新浏览器，由 `webpack-dev-server` 模块负责，需要注意，使用 devServer 是默认开启文件监听并构建的，监听功能开启，***所以不用再在配置中添加上述步骤 i 中的配置选项***。\n\n>这里不再说明 webpack-dev-serevr 的使用方法，只讲它的自动刷新浏览器的原理：向要开发的网页中注入代理客户端的代码，通过代理客户端去刷新整个页面。为了优化自动刷新的性能，可以关闭 devServer 的 inline 模式，因为 inline 模式会向每一个输出的 Chunk 注入一个代理客户端的代码，当项目需要输出很多个 Chunk 时，就会导致构建缓慢。实际上要完成自动刷新，一个页面只需一个代理客户端，DevServer 之所以粗暴的为每一个Chunk都注入，是因为它不知道某个网页以来哪几个Chunk，索性全部都注入一个代理客户端。为了关闭 inline 模式，可以在启动 webpack devserver 的命令中加上 --inline false 参数，如`webpack-dev-server --inline false`也可以在配置文件中设置。\n\n##### 6.6 使用模块热替换\n\t\t\n比上述自动刷新页面更好的实时预览，可以保留应用上次的状态，而且等待时间更短。模块热替换的原理也是使用了客户端代理注入，实现模块热替换的方式有2种，可以在执行 webpack-dev-server 命令时，加上 --hot ，也可以用插件 HotModuleReplacementPlugin( )  实现，并且设置 devServer 的参数 hot 为 true。\n\t\t\n需要注意的是：对于 CSS 文件和 JS 文件的修改所引起的模块热替换会有不同的表现。当修改 CSS 文件时，模块热替换会起作用，网页的样式会立刻改变，但是修改 JS 文件，会发现整个网页都被刷新了，没有模块热替换的效果，这是因为在CSS文件中，style-loader 会注入用于接收CSS的代码，当更新 CSS 依赖模块时，此 loader 在后台使用 module.hot.accept 来修补(patch) `<style>` 标签。如果我们想让JS文件也有模块热替换的效果，而不是刷新整个网页，可以在使用该模块的上层模块使用 module.hot 用于接收控制更新模块，module.hot.accept([ './component.js' ] , callback ) ,当接收到更新事件时就会调用 callback 去执行自定义逻辑，比如接受到新模块时，将它重新挂载到某个节点，如果我们没有接收模块更新事件的逻辑，更新事件一层层的往上抛，而没有文件接收它，就会直接刷新整个网页。\n\t\t\n我们可以优化 模块热替换 的使用体验，比如使用 NamedModulesPlugin 插件，可以命名被替换的模块。\n\t\t\n社区还有许多其他 loader 和示例，可以使 HMR 与各种框架和库(library)平滑地进行交互……\n\n  **React Hot Loader**：实时调整 react 组件。\n\t\t\t\n  **Redux HMR**：无需 loader 或插件！只需对 main store 文件进行简单的修改。\n\t\t\n\t\t \n最后，模块热替换在生产版本中应该除去。\n\n##### 6.7 区分环境：生产环境/开发环境\n\t\n为什么要区分环境：\n\t\t\n- i. 开发环境需要一些方便开发者调试的代码，比如输出日志，而线上环境是面向用户，不能暴露这些日志；\n\t\t\t\t\n- ii. 开发环境用的后段数据接口不能和真正的线上环境一样，以免影响线上数据接口；\n\t\t\t\t\n- iii. 一些第三方库如 React 源码中包含 环境区分 的逻辑，比如在开发环境会有一些用于调试日志输出的代码，线上环境则会除去这些代码，所以为了最后线上环境代码最小化，我们要定义构建环境变量为 production\n\t\t\t\t\n定义环境变量，在生产环境配置webpack.prod.js里为引入的依赖库指定生产环境，可以使这些库在用户环境里优化自身的代码。：\n```js\nnew webpack.DefinePlugin({\n       'process.env.NODE_ENV': JSON.stringify('production') \n     })\n```\n\n##### 6.8 压缩代码（JS/CSS）：可以优化用户的代码加载速度\n\t\n**压缩JS**：可以使用自定义 UglifyJsPlugin 或者 ParallelUglifyJsPlugin 插件的方式，也可以在执行命令 webpack 时带上 --optimize-minimize 参数；\n\t\t\n**压缩ES**：一些 JS 引擎可以支持 ES 6 ，比如 ReactNative 的 引擎 JavaScriptCore 和 Chrome ，因为 ES 6 代码更加简洁还有 JS引擎对 ES6 做了优化，如果 JS 运行环境允许直接允许 ES6 ，那么我们应该直接使用 ES6，而不是去转化为 ES5，此时我们压缩代码，就不能再用上面的  UglifyJsPlugin，因为它用的是  UglifyJs ，只支持压缩 ES5 ，为了支持压缩 ES6 ，我们可以使用  ParallelUglifyJsPlugin 的压缩 ES6 的选项，也可以使用专门针对 压缩 ES6 代码的插件：Uglify-webpack-plugin;\n\t        \n**压缩 CSS**：css-loader 内置了 cssnano 这个压缩 CSS 的工具, 要开启 css-loader 的压缩 CSS 的功能，只需在 css-loader 后加上 `?minimize` 参数\n\n##### 6.9 CDN 加速\n\n将构建好的资源放到 CDN 服务器上，使资源分布在用户最近的服务器上，用户在首次加载时就可以更快速的获取到资源。建议把 html 和 数据接口放在自己的服务器上，而把 JS、CSS、图片等放在 CDN 上。在 Webpack 打包过程中可以设置输出资源放到哪个 CDN 上，通过设置 output.publicPath 为 CDN URL ，打包出来的 JS 在 html 文件中的路径就会加上 CDN 路径，然后我们只需把打包的 js 放在CDN上即可，如果我们只想把一些图片资源放在 CDN 上，我们可以只在处理图片的 Loader 中加上 publicPath，那么一般不会把 JS 放在 CDN上；而对于 CSS，可以在处理 CSS 的 loader 配置的地方 分离 CSS 的插件 ExtractTextPlugin 参数中传入 publicPath ，最后，在生产 html 的插件 HtmlWebpackPlugin 的参数中传入  stylePublicPath 项。\n\t\n针对使用 CDN 存放资源，有以下几个优化建议：\n\t\t\n- i. html 和 数据接口放在自己的服务器上，而把 JS、CSS、图片等放在 CDN 上;\n\t\t\t\n- ii. 对于放在 CDN 上的资源，开启 CDN 和 缓存，即上传到 CDN 上，同时为每一个文件名带上根据内容计算出的 hash 值，带上 hash 值后文件名会随着 文件内容的变化而变化，只要文件名变化，那么其 URL 也就变化，那么就会重新下载。\n\n##### 6.10 Tree Shaking 剔除死代码\n\n使用 Tree Shaking 只对静态导入 import 有效，require不支持 Tree Shaking， 动态导入 import 无法判断。可以看笔记。\n\t\n##### 6.11 提取公共代码\n\n将相同的代码被抽离出来放在一个单独的文件，可以减小资源体积，优化加载速度。可以看笔记.\n\t\n将 chunk a 和 chunk b 中的公共代码提取到 chunkn common 中：\n```js\n\t\tnew CommonschunkPlugin({\n\t\t          chunk : ['a', 'b'],\n\t\t\t  name : 'common'\n\t\t})\n```\n\n![image](/imgs_from_article/1578024957511__article-img__commonschunk.JPG)\n\n我自己加入的笔记补充：如果是对多个页面公共代码的提取，提取代码后还要把代码挂载到 html 文件，为此，需要使用 HtmlWebpackPlugin  插件，来自动将各个 chunk 挂载到对应的 页面 html 中。这就涉及多页面应用的打包，可以多次使用 HtmlWebpackPlugin ：\n\n```js\n\t\tnew HtmlWebpackPlugin({\n\t\t      template:'./index.html'.\n\t\t      filename:'a.html',\n\t\t      chunks:['a', 'common']\n\t\t}),\n\t\tnew HtmlWebpackPlugin({\n\t\t      template:'./index.html'.\n\t              filename:'b.html',\n\t\t      chunks:['b','common']\n\t        }),\n```\n\n##### 6.12 分割代码以按需加载（懒加载）\n\n用户在加载网页资源的时候，只加载自己需要的部分，这样就可以避免因为资源过大加载缓慢的问题。关于怎么实现代码分割 看笔记。为了实现动态加载模块，不仅要使用动态 import ，如果动态import （）中使用注释参数指定了被动态导入的 chunk 名，即在动态 import 中为动态生成的 Chunk 赋予了一个名称，那么需要在 webpack 配置中指定动态生成的 Chunk 名，设置 output.chunkFilename : '[ name ].js', 指定动态生成的 Chunk 在输出时的文件名称。如果没有这一行，则分割出的代码的文件名称将会是 [id].js。\n\t\n⚠️： 代码分割将需要动态引入的代码单独打包在一个Chunk里，有点像上述的提取公共代码，两者本质上都是代码分割，只不过，提取的公共代码需要用户在第一次加载页面时就要加载，不管用户端有没有运行到这部分；而代码分割也是把需要动态导入按需加载的代码事先打包到一个单独的Chunk中，只是在用户首次加载页面时不会加载这个Chunk，而是在用户需要的时候才动态加载。\n\t\n一个结合 React router 与 按需加载路由组件的例子：定义一个异步获取组件的高阶组件（也可以使用自定义 Hooks），在这个高阶组件里会调用 import ( * ) 动态导入组件，而在React router的 <Route />中将其 component 属性设置为这个高阶组件，向高阶组件传入需要按需加载的组件的路径和Chunk名，这样就实现了动态导入每一个路由组件，不用首次加载就把所有的组件加载进来。由于 React 需要 Babel 编译，而 Babel 需要 babel-plugin-syntax-dynamic-import 这个插件才能理解 import( * )动态导入语句，因此需要在 Babel 配置文件 .babelrc 中加入这个插件。\n\t\n##### 6.13 使用 Prepack\n\n上述的优化比如代码分割压缩等只是在 网络加载层面的优化。而 prepack 跨域在代码运行阶段优化。prepack 预先在编译阶段就执行源码，将一些变量预先计算出来，这样就加快了代码的运行速度。不过 prepack 存在不足，因为还处于开发阶段，对一些 DOM API 和 Node APi不识别，优化后性能可能更差。使用 prepack 的方法是，下载使用 prepack-webpack-plugin 插件。\n\t\n##### 6.14 开启 Scope Hoisting （作用域提升）\n\n可以让打包出来的代码更小，运行更快。原理是分析模块之间的依赖关系，尽可能将打散的模块合并到一个函数中，由于要分析模块的依赖关系，因此源码必须采用 ES6 模块和语句。开启 Scope Hoisting 的方法只需加入 内置 的 ModuleConcatenationPlugin 插件，对于第三方库在 Commonjs 之外可能还提供采用了 ES6 模块化语法，所以可以在 resolve.mainFields 中将‘jsnext:main' 放在首位。\n\t\n##### 6.15 分析构建输出结果以决定下一步优化\n\n以可视化方法得到构建的分析数据，\n\t\t\n- step1: 在执行 webpack 构建是带上 --profile --json 参数：\n\n>--profile 表示记录构建过程中的耗时；\n  --json 表示以 JSON的格式输出构建结果\n\t\t\t\n比如, 使用管道命令将结果输出到文件 buildstats.json 中：\n> webpack --mode production --profile --json > buildstats.json\n\n- step2：打开 webpack 的官方web应用（webpack.github.io/analise/)，然后打开上面生成的  buildstats.json 文件：即可查看所有依赖模块的信息和加载时间等。\n\n![image](/imgs_from_article/1578025400188__article-img__分析构建结果1.png)\n![image](/imgs_from_article/1578025412580__article-img__分析构建结果2.png)\n![image](/imgs_from_article/1578025423615__article-img__分析构建结果3.png)\n\n此外还有 webpack-bundle-analyze 这个工具也可以可视化分析 webpack 构建结果。\n\n### 7. 原理以及自己编写 loader 和 plugin\n\n在某些情况下我们的需求可能在社区中找不到解决方案，我们可以自己编写 loader 或者 plugin，因此在这之前我们需要先理解 webpack 的原理。\n\t\n##### 7.1 webpack 的工作原理：\n\t\nwebpack 的运行是一个窜行过程，依次经过：\n\t\n>初始化（读取合并参数，加载 plugin，实例化 Compiler）------> 编译（从 Entry 出发，对每一个 Module 窜行调用对应的 Loader 去处理翻译文件的内容，再找到改 Module  所依赖的 Module，递归地编译处理下去 -----> 输出（将编译后的 Module 组合为 Chunk，将 Chunk 转换为文件输出到文件系统）\n\t\n如果开启监听模式，流程就是：\n\n![image](/imgs_from_article/1578025512369__article-img__webpack流程.JPG)\n\n在以上3个阶段都会产生各种事件，这些事件会触发 Plugin 。\n\t\n##### 7.2 自己编写 Loader\n\nloader 的原理是接收上一个 loader 的输出，对其做处理再输出给下一个 loader（如果一个文件有多个 loader 处理），就像 express 中间件一样，又像 Node 中的流。\n\t\n先来看一个简单的 loader ：这是一个将文件中 @require ' ../somefile ' 语句改为 require ' ../somefile '的loader：地址  https://github.com/gwuhaolin/comment-require-loader。\n\t\n然后再看怎么编写一个自己的 loader，然后测试、并发布到 npm：\n\t\n编写自定义loader可以使用一些工具库比如： `loader-utils`\n\n##### 7.3 自己编写 Plugin：(待填坑）\n\n### 8. 常用的 Loader\n\n##### 8.1 加载文件：\nloader | 作用\n:-: | :-: \nfile-loader|将文件输出到一个文件夹，在代码里通过相对 URL 引用输出的文件\nurl-loader\t| 以 base64 方式将文件内容注入代码\nsource-map-loader | 加载额外的 SourceMap 文件，发布断点调试\nnode-loader|加载 Node 原生模块的 .node 文件\njson-loader|加载loader，webpack 其实内置支持引入 JSON，不用自己引入这个 Loader\nraw-loader|加载文本文件的内容到代码里\nSVG-inline-loader|将压缩后的 SVG 注入到代码\nimage-loader|加载并压缩图片文件\n\t\n##### 8.2 编译模版：\nloader | 作用\n:-: | :-: \npug-loader|将 Pug 模版转换为 Javascript 并返回\nejs-loader\t| 将 EJS 模版转换为 Javascript 并返回\nmarkdown-loader|将 Markdown 文件转换为 HTML\n\t\n##### 8.3 转换脚本语言：\nloader | 作用\n:-: | :-: \nbabel-loader|ES6 ->  ES5\nts-loader|ts ->JS\nawsome-typescript-loader|\t比 ts-loader 更好的 TS 转换器\ncoffee-loader| CoffeeScript -> JS\n\n##### 8.4 转换样式文件：\nloader | 作用\n:-: | :-: \ncss-loader\t|加载 CSS，支持模块化、压缩、文件导入等，css-loader: 加载.css文件\nstyle-loader|将 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载  CSS，style-loader:使用`<style>`将css-loader内部样式注入到我们的HTML页面\n|sass-loader|SCSS/SASS -> CSS\npostcss-loader\t|扩展 CSS 语法，下一代 CSS\nless-loader|Less -> CSS\nstylus-loader|Stylus -> CSS\n\t\n##### 8.5 检查代码：\n一般编辑器带有代码检查的扩展，所以可以忽略此种 loader：\n\neslint-loader、tslint-loader、converjs-loaderr、mocha-loader\n\t\n##### 8.6 其他 loader：\nloader | 作用\n:-: | :-: \nignore-loader|忽略部分文件\nui-component-loader|按需加载 UI 组件，比如在使用 antdUI 时，不会因为只用到了 Button 组件就打包所有组件\n\n### 9. 常用的 Plugin\n\n##### 9.1 用于修改行为：\nloader | 作用\n:-: | :-: \ndefine-plugin|定义环境变量\nignore-plugin|忽略部分文件\nprovide-plugin|自动引入模块而不用使用 import 或者 require\ncopy-plugin|拷贝文件从一个路径到另一个路径\nadd-asset-html-webpack-plugin\t|将静态资源加入到 html。比如一些在一个 webpack 配置中打包好的 js 文件加入到另一个 webpack 配置中的 HTML 模版中时需要我们手动加入，这是我们可以在后面那个 webpack 配置中这是要这个插件。\n\t\n##### 9.2 用于优化：\nloader | 作用\n:-: | :-: \ncommons-chunk-plugin|提取公共代码\nextra-text-webpack-plugin\t|提取 jacascript 中的 CSS 代码到单独的文件（这个已经不支持，请使用 mini-css-extract-plugin）\nprepack-webpack-plugin|Facebook 的 prepack 优化输出的 JavaScript 代码的运行性能\nuglifyjs-webpack-plugin|通过 eglifyES 压缩 ES6 代码\nwebpack-parallel-uglify-plugin|多进程执行 UglifyJS 代码压缩，提高构建速度\nimagemin-webpack-plugin|压缩图片文件\nwebpack-spritesmith|制作雪碧图\nmoduleConcatenationPlugin\t| 开启 作用域提升\ndll-plugin 和 DllReferencePlugin|借鉴 DDL 动态连接库的思想提神构建速度\nhot-module-replacement-plugin|开启模块热替换的功能\n\t\n##### 9.3 其他插件\nloader | 作用\n:-: | :-: \nserviceworker-webpack-plugin|为网页应用增加离线缓存功能\ni18-webpack-plugin|使网页支持国际化\nweb-webpack-plugin|方便地为单页应用输出 HTML，比 html-webpack-plugin 好用\nprovide-plugin|从环境中提供的全局变量中加载模块，而不用导入对于的文件\n\n","lastModified":"2020/1/3 下午12:38:04","tags":["原创","前端","javascript","Node","Webpack"]}