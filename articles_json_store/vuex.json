{"title":"vuex","content":">在很多应用中，我们都需要向服务端提供自己的身份凭证来获得访问一些非公开资源的授权。比如在一个博客平台，我们要修改自己的博客，那么服务端要求我们能够证明  “我是我” ，才会允许我们修改自己的博客。\n\n为用户提供授权以允许用户操作非公开资源，有很多种方式。比如使用 token、session、cookie，还有允许第三方登录授权的 OAuth 2.0.\n\n![image](/imgs_from_article/1577281301374__article-img__71A790B8-5B34-4FAB-B968-4F7F12C4A241_4_5005_c.jpeg)\n\n为了理解这些技术的机制和它们之间的关系，本文就来一一使用这些方案实现一个前端通过后端验证授权来访问后端服务的应用。\n\n我们将用 express 搭建一个简单的后端，为了保存用户信息，我们使用 mongoDB。前端是一个注册页面和一个登录页面，此外还有一个修改用户密码的页面，在这个页面上修改密码的操作只有在用户登录之后才被允许，也就是被服务端授权之后才能修改密码，否则返回 401 未授权。\n\n下面就是我们这个简单 demo 的文件结构：\n\n*服务端结构：*\n\n如上图，我们在服务端写了4个路由分别用于用户注册、登录、修改密码、和登出。其中在登录路由中，用户登录之后将会生成一个用户凭证，在后续修改密码的路由中将会利用这个凭证来授权用户修改密码。具体的代码根据不同的授权方案而有所不同。前端相应地分为注册、登录、修改密码 3 个页面：\n\n\n\n搭建起一个前后端分离的应用框架之后，我们下面依次使用 token、OAuth 2.0、express-session 来实现用户授权。\n\n## 1. 使用 session 授权\n###  1.1 session 原理：\n利用 session 来验证用户，有两种机制实现。\n \n>1. 需要服务端在用户登录成功后生成一个 session ID 保存在服务端，这个session ID 标识当前会话的用户，以后用户的每一次请求中都会包含session ID，服务端可以识别这个 session ID 验证用户身份然后才会授权。\n\n>2. 把 session ID 和其他数据加密后发给用户，由用户来存储并在以后每次请求中发给服务端来验证。比如可以用 cookie 存储发送，也可以使用其他客户端存储。\n\n\n###  1.2 express-session API：\n本文使用 express-session 来实现。并且使用上述 session 的第一种机制。所以先来看一下 [express-session](https://www.npmjs.com/package/express-session) 主要的 API：\n\n- **session( options )**：生成 session 中间件，使用这个中间件会在当前会话中创建 session，session 数据将会被保存在服务端，而 session ID 会保存在 cookie。options 为传入的配置参数，有以下这些参数：\n\n      1.  cookie：\n             存储 session ID，\n             默认值 { path: ‘/‘, httpOnly: true,secure: false, maxAge: null }）\n      2.  genid：\n             一个函数，返回一个字符串用来作为新的 session ID，传入 req 可以按需在 req 上添加一些值。\n      3.  name：\n             存储 session ID 的 cookie 的名字，默认是'connect.sid'，但是如果有多个使用 express-session 的 app 运行在同一个服务器主机上，需要用不同的名字命名  express-session 的 cookie。\n      4.  proxy ：\n             当设置了secure cookies（通过”x-forwarded-proto” header ）时信任反向代理。\n      5.  resave：\n             强制保存会话，即使会话在请求期间从未被修改过\n      6.  rolling：\n             强制在每次响应时，都设置保存会话标识符的cookie。cookie 到期时间会被重置为原始时间 maxAge。默认值为`false`。\n      7.  saveUninitialized：\n             默认 `true`, 强制存储未初始化的 session。\n      8.  secret ( 必需 ）:\n             用来对session ID cookie签名，可以提供一个单独的字符串作为 secret，也可以提供一个字符串数组，此时只有第一个字符串才被用于签名，但是在 express-session 验证 session ID   的时候会考虑全部字符串。 \n      9.  store:\n             存储 session 的实例。\n      10. unset：\n             控制 req.session 是否取消。默认是 `keep`，如果是  `destroy`,那么 session 就会在响应结束后被终止。\n             \n- **req.session**：这是 express-session 存放 session 数据的地方，注意，只有 session ID 存储在 cookie，所以 express-session 会自动检查 cookie 中的 session ID ，并用这个 session ID 来映射到对应的 session 数据，所以使用 express-session 时我们只需读取 req.session ，express-session 知道应该读取哪个 session ID 标识的 session 数据。\n  \n      1. 可以从 req.session 读取 session ：\n             req.session.id：每一个 session 都有一个唯一ID来标识，可以读取这个ID，而且只读不可更改，这是 req.sessionID 的别名；\n             req.session.cookie：每一个 session 都有一个唯一 的cookie来存储 session ID，可以通过 req.session.cookie 来设置 cookie 的配置项，比如 req.session.cookie.expires 设置为 false ，设置 req.session.cookie.maxAge 为某个时间。\n      2. req.session 提供了这些方法来操作 session：\n             req.session.regenerate( callback (err) ): 生成一个新的 session, 然后调用 callback；\n             req.session.destroy( callback (err) ): 销毁 session，然后调用 callback；\n             req.session.reload( callback (err) ):  从 store 重载 session 并填充 req.session ，然后调用 callback；\n             req.session.save( callback (err) ): 将 session 保存到 store，然后调用 callback。这个是在每次响应完之后自动调用的，如果 session 有被修改，那么 store 中将会保存新的 session；\n             req.session.touch(): 用来更新 maxAge。\n\n- **req.sessionID**：和 req.session.id 一样。\n- **store**：如果配置这个参数，可以将 session 存储到 redis和mangodb 。[一个使用 rtedis 存储 session 的例子](https://github.com/tj/connect-redis)。store 提供了一下方法来操作 store：\n\n      1. store.all( callback (error, sessions) ) ：\n             返回一个存储store的数组；\n      2. store.destroy(sid, callback(error))：\n             用session ID 来销毁 session；\n      3. store.clear(callback(error))：\n             删除所有 session\n      4. store.length(callback(error, len))：\n             获取 store 中所有的 session 的数目\n      5. store.get(sid, callbackcallback(error, session))：\n             根据所给的 ID 获取一个 session\n      6. store.set(sid, session, callback(error))：\n             设置一个 session。\n      7. store.touch(sid, session, callback(error))：\n              更新一个 session\n\n以上就是 express-session 的全部 API。\n\n### 1.3 使用 express-session\n*重点中的重点，巨坑中的巨坑*：使用 express-session 是依赖于 cookie 来存储 session ID 的，而 session ID 用来唯一标识一个会话，如果要在一个会话中验证当前会话的用户，那么就要求用户前端能够发送 cookie，而且后端能够接收 cookie。所以前端我们设置 axios 的 withCredentials = true 来设置 axios 可以发送 cookie，后端我们需要设置响应头 Access-Control-Allow-Credentials:true，并且同时设置 Access-Control-Allow-Origin 为前端页面的服务器地址，而不能是` * `。我们可以用 cors 中间件代替设置：\n```js\n// 跨域\n\napp.use(cors({\n  credentials:  true,\n  origin:  'http://localhost:8082',  // web前端服务器地址，，不能设置为 * \n\n}))\n```\n我开始就是因为没有设置这个，所以遇到了问题，就是后端登录接口在session中保存 用户名（ `req.session.username = req.body.username`） 之后，在修改用户密码的接口需要读取  `req.session.username` 以验证用户的时候读取不到 `req.session.username` ，很明显两个接口的 `req.session` 不是同一个 `session`，果然 console 出来 的 `session ID` 是不同的。这就让我想到了 cookie，cookie 是生成之后每次请求都会带上并且后端可以访问的，现在存储在 cookie 中的 session ID 没有被读取到而是读取到了新 session ID，所以问题就出在后端不能拿到 cookie，也有可能是因为前端发送不出去 cookie。可是开始的时候搜索关于 session ID 读取不一致的这个问题我找不到解决办法，而且发现很多人存在同样的问题，但是没有人给出答案，现在通过自己的思考想到了解决办法，这是很多人需要避免的巨坑。\n\n现在跨过了最大的一个坑，我们就可以来编写前后端所有的逻辑了。关于注册的逻辑，是一个很简单的用户注册信息填写页面，它发送用户的名字和密码到后端注册接口，后端注册接口保存用户的名字和密码到数据库理。因此我在这里省略掉前端注册页面和后端注册接口，只讲前端登录页面和后端登录接口，前端修改密码页面和后端修改密码接口和登出接口。\n\n\n\n- 1. 前端登录接口：\n\n```js\nasync function login(){ // 登录\n         \n        let res = await axios.post('http://localhost:3002/login',{username,password})\n        if(res.data.code === 0){\n            setLoginSeccess(true)\n            alert('登录成功,请修改密码')\n            \n        }else if(res.data.code === 2){\n            alert('密码不正确')\n            return\n        }else if(res.data.code === 1){\n            alert('没有该用户')\n            return\n        }\n    }\n```\n- 2. 后端登录接口：\n\n```js\nconst getModel = require('../db').getModel\nconst router = require('express').Router()\nconst users = getModel('users')\n\nrouter.post('/', (req,res,next)=>{\n    let {username, password} = req.body\n    users.findOne({username},(err,olduser)=>{\n        if(!olduser){\n            res.send({code:1})// 没有该用户\n        }else{\n            if(olduser.password === password){// 登陆成功，生成 session\n                req.session.username = olduser.username\n                req.session.userID = olduser._id\n                console.log('登录时的会话 ID：',req.sessionID)\n                req.session.save()\n                res.send({code:0})// 登录成功\n            }else{\n\n                res.send({code:2}) // 密码错误\n            }\n        }\n    })\n})\n\nmodule.exports = router\n```\n- 3. 前端修改密码和登出页面：\n```js\n// src/axios.config.js:\n\n// 支持 express-session 的 axios 配置\nexport function axios_session(){\n    axios.defaults.withCredentials = true\n    return axios\n}\n```\n\n\n```js\nasync function modify(){ // 修改密码\n       if(!input.current.value) return alert('请输入新密码')\n       try{\n           // 支持 session 的 axios 调用\n           let res = await axios_session().post('http://localhost:3002/modify',{newPassword:input.current.value})\n           if(res.data.code === 0)\n               alert('密码修改成功')\n       }catch(err){\n           alert('没有授权 401')  \n           console.log(err)\n       }\n}\n```\n\n```js\nasync function logout(){ // 登出\n        let res = await axios.post('http://localhost:3002/logout')\n        if(res.data.code === 0){\n            history.back()\n        }\n}\n```\n\n- 4. 后端修改密码接口：\n\n```js\nconst getModel = require('../db').getModel\nconst router = require('express').Router()\nconst users = getModel('users')\nconst sessionAuth = require('../middlewere/sessionAuth') \n\nrouter.post('/', sessionAuth, (req,res,next)=>{\n    let {newPassword} = req.body\n    console.log('修改密码时的会话 ID：',req.session.id)\n    if(req.session.username){\n        users.findOne({username: req.session.username},(err,olduser)=>{\n            olduser.password = newPassword\n            olduser.save(err=>{\n                if(!err){\n                    res.send({code:0})// 修改密码成功\n                }\n            })\n        })\n    }\n})\n\nmodule.exports = router\n```\nsessionAuth 验证中间件：\n```js\nconst sessionAuth = (req,res,next)=>{\n    if(req.session && req.session.username){// 验证用户成功则进入下一个中间件来修改密码\n        next()\n    }else{// 验证失败返回 401\n        res.sendStatus(401)\n    }\n}\n\nmodule.exports = sessionAuth\n```\n\n","lastModified":"2019/12/25 下午9:43:13","tags":["Vue"]}