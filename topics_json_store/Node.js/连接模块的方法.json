{"title":"连接模块的方法","articleTopic":"Node.js","content":"### 模块连接的方法：\n\n\n\n\n#### 1）*硬编码依赖*：简单的导出和引入模块实例.\n\n                      缺点：模块是有状态的，难以重用和测试。\n\n#### 2）*依赖注入（DI）*：使用类似 `modeula.exports = (somedata) =>{ return fn(){….}} 和 require('./fn')(data)` 导出和引入。\n\n                      类型：工厂注入，就是导出一个工厂方法，就是上面那种；\n\n                      构造器注入，就是导出构造器， `modeula.exports = data =>  new fn(data)` ;\n\n                      属性注入， `modeula.exports =（） => { dependcyenA:  fn(){….} } 和 require('./fn').dependcyenA`\n\n                      优点：模块是无状态的，有更好的测试性和解藕性。（有点像纯函数？），延迟模块的初始化（异步模块）。\n\n                      缺点：依赖注入的模块依赖关系难以理解。\n\n\n\n\n#### 3）*服务定位器*：有一个中央注册表用于管理系统的组件，并在每个模块需要加载依赖时充当调节器。在需要的时候在注册表中检索需要的依赖。服务定位器里提供了注册各种依赖的方法和获取这些方法的方法，服务定位器作为一个对象被其他模块引用，其他模块可以调用这个对象里的方法来注册依赖或获取依赖。\n\n\n\n\n实现服务定位器本身：（注：factory 用于将组件名称与工厂关联，register 用于将组件名称于实例关联，get 按名称检索组件）\n\n\n\n\n![image](/imgs_from_article/1581049548074__article-img__IMG_4605.JPG)\n\n\n\n\n实例化和配置服务定位器：（注：下面的 require('./lib/db/') 模块里面是用服务定位器获取依赖的方法获取了注册表中的dbName 依赖，其他 require('./lib/authService'）也是一样的）\n\n\n\n\n![image](/imgs_from_article/1581049600672__article-img__截屏2020-02-07下午12.26.20.png)\n\n\n\n\n服务定位器的 缺点：与DI一样组件之间的关系难以识别，因为它们在运行时才被解析。\n\n\n\n\n#### 4）依赖注入容器（DI 容器）：DI容器本质上就是服务定位器，区别就是，DI容器在实例化之前就标识模块的依赖需求。DI容器结合了 DI 和 服务定器的概念，因为 DI 没有容器概念，而服务定位器有，但是服务定位器的模块依赖关系只有在运行时才被解析，关系没有 DI 通过工厂函数传入依赖作为参数时依赖之间的关系那么清晰，所以 DI 容器是为了结合着两者。\n\n#### 5）使用 npm 包如 node-dependency-injection DI 容器来连接模块，不用自己编写 DI 容器，可以拿来即用。"}