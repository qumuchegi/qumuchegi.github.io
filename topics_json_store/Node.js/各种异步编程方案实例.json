{"title":"各种异步编程方案实例","articleTopic":"Node.js","content":"首先来看一下 **顺序执行**、**并行执行**、**有限制的并行执行** 这三个概念的准确表述：\n\n\n\n\n<span style=\"color: blue\">顺序执行</span>：一种是顺序执行一组已知任务（适用于任务数量实现知道），另一种是顺序迭代未知任务：（任务数量是动态的）;\n\n\n\n\n<span style=\"color: red\">并行执行</span>：一组任务的执行顺序不重要，重要的是所有任务的结果出来后能得到通知执行回调（并行的说法并不准确，应该为并发，因为所有任务并不是同时执行，而是由底层的非阻塞API执行，并由事件循环进行交叉运行）；\n\n\n\n\n<span style=\"color: green\">有限制的并行执行</span>：限制可以同时运行的任务数，确保应用程序不会耗尽资源\n\n \n\n### 1. Node 回调风格的异步控制（自定义回调）：\n\n\n\n\n##### 1.1 顺序执行：\n\n###### a. 顺序执行一组已知任务（适用于任务数量已经知道）\n\n```js\n\nfunction task1(callback){\n  asyncOperation(()=>{\n    console.log('task1 被执行，进入 task2')\n    task2(callback)\n  })\n}\nfunction task2(callback){\n  asyncOperation(()=>{\n    console.log('task2 被执行，进入 task3')\n    task3(callback)\n  })\n}\nfunction task3(callback){\n  asyncOperation(()=>{\n    console.log('task3 被执行')\n    callback()\n  })\n}\n\n\ntask1(()=>{\n  console.log('task1,2,3 被执行')\n})\n\n\nfunction asyncOperation(cb){\n cb()\n}\n```\n输出：\n```js\ntask1 被执行，进入 task2\ntask2 被执行，进入 task3\ntask3 被执行\ntask1,2,3 被执行\n```\n\n\n\n\n\n###### b.  顺序迭代未知任务：（任务数量是动态的）\n\n将任务组成数组传入函数，这个函数依次迭代这个数组，每次迭代到一个任务把当前结果（可选）传入下一个任务。\n\n\n```js\nlet tasks = [\n  (cb)=>{\n    console.log('第0个task')\n    cb()\n  },\n  (cb)=>{\n    console.log('第1个task')\n    cb()\n  },\n  (cb)=>{\n    console.log('第2个task')\n    cb()\n  }\n]\nfunction iterate(index){\n  if(index===tasks.length){\n    return finish()\n  }\n  const task=tasks[index]\n  task(function(){\n    iterate(index+1)\n  })\n}\nfunction finish(){\n  // iteration finish\n  console.log('迭代完成')\n}\niterate(0)\n```\n\n\n输出：\n```js\n第0个task\n第1个task\n第2个task\n迭代完成\n```\n##### 1.2 并行执行\n```js\nconst tasks=[\n  (cb)=>{\n    console.log('第0个task')\n    cb()\n  },\n  (cb)=>{\n    console.log('第1个task')\n    cb()\n  },\n  (cb)=>{\n    console.log('第2个task')\n    cb()\n  }\n]\nlet complete=0\ntasks.forEach(task=>{\n  task(()=>{\n    if(++complete===tasks.length){\n      finish()\n    }\n  })\n})\nfunction finish(){\n  console.log('所有task完成')\n}\n```\n\n\n输出：\n\n\n```js\n第0个task\n第1个task\n第2个task\n所有task完成\n```\n\n\n##### 有限制的并行执行\n```js\nconst tasks=[\n  (cb)=>{\n    console.log('第0个task')\n    cb()\n  },\n  (cb)=>{\n    console.log('第1个task')\n    cb()\n  },\n  (cb)=>{\n    console.log('第2个task')\n    cb()\n  },\n  (cb)=>{\n    console.log('第3个task')\n    cb()\n  },\n  (cb)=>{\n    console.log('第4个task')\n    cb()\n  },\n  (cb)=>{\n    console.log('第5个task')\n    cb()\n  }\n]\nlet concurrency=2,running=0,complete=0,index=0\n\n\nfunction next(){\n  while(running<concurrency && index<tasks.length){\n    let task=tasks[index++]\n    task(()=>{\n      if(complete===tasks.length-1){\n        return finish()\n      }\n      complete++, running--\n      next()\n    })\n    running++\n  }\n}\nnext()\nfunction finish(){\n  console.log('所有task完成')\n}\n\n\n```\n\n\n\n### 2. 使用 async 库：（这个可以查看官网的API，它的顺序、并行、有限制的并行执行都有若干数量的方法）\n\n\n\n### 3. 使用 promise\n\n\n\n##### 3.1 顺序执行（迭代）\n\n```js\nlet promise = Promise.resolve()\ntasks.forEach(task=>{\n  promise = promise.then(()=>{\n    return task()\n  })\n})\npromise.then(()=>{\n  console.log('所有tasks完成')\n})\n```\n\n\n可以使用 `reduce` 改写，更加简洁：\n```js\nlet promise = tasks.reduce((prev,task)=>{\n    return prev.then(()=>{\n      return task()\n    })\n  }, Promise.resolve())\npromise.then(()=>{\n  console.log('所有tasks完成')\n})\n```\n\n\n\n##### 3.2 并行执行：使用内置的 promise.all() 即可\n\n\n\n\n### 4. generator ：生成器允许暂停函数的执行，稍后再回复，这刚好可以用来写异步代码。\n\n\n### 5. co库 ：基于 generator 的异步控制流库，支持几种类型的 yield：\n\n\n\n\n\nthunk、promise、Array (并行执行）、Object (并行执行）、Generator（委托）、Generator function（委托）\n\n\n\n\n\n### 6. 使用 Babel 的 `async / await` : 需要引入 Babel和一些配置。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}