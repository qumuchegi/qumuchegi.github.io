{"title":"Node.js 基础设计模式","articleTopic":"Node.js","content":"# 回调模式、观察者模式（事件发射接收）、模块系统及其模式（module.exports、exports）\n\n \n\n## 1. Node 的异步和回调\n\n\n\n\nNode 中回调模式并不一定是异步的，回调是被调用来传播操作结果的函数，这正是处理异步操作结果时所需要的。Node 的异步编程风格 第一要归功于它所封装的 回调形式 的API（**连续传递风格，将回调作为参数传入**），比如 `fs.readFile(filename,(err,data)=>{})`，即在函数参数传入一个回调函数，在异步操作结果出来时调用这个回调函数；第二归功于 事件发射器（观察者模式），Node有一个EvevtEmitter类，可以注册事件及其监听器，提供了事件发射和接受方法，可以一对多地传播事件，这也实现了处理异步操作结果。（当然，Node 的异步编程方法还有使用`promise,async-await`,还可以使用 异步逻辑控制工具 `async` 库等）\n\n\n\n\n## 2.回调地狱\n\n\n\n\n是大量的闭包和就地定义的回调函数使代码变得不可读并难以控制的现象。\n\n\n\n\n避免回调地狱的方法：\n\n\n\n\n-  1. 尽早 return；\n\n-  2. 为回调创建命名函数并保持在闭包之外，将中间结果作为参数传递；\n\n-  3. 拆分代码为更小模块。\n\n \n\n## 3. Node.js 回调的异步实现的机制\n\n\n\n\nNode.js 回调的异步实现的机制是，使回调延迟执行，这可以通过使用 setTimeout 在将来一段时间后执行，也可以使用process.nextTick()，和 setImmediate().\n\n \n\n`process.nextTick()`，和 `setImmediate()` 的区别：\n\n\n\n\n>(1) `process.nextTick()`，它的作用是延迟一个函数的执行，直到下一次事件循环，将回调函数作为参数推到事件队列的顶部，在任何待处理的I/O事件之前返回。一旦事件循环再次运行，回调回立即执行。\n\n\n\n\n>(2) `setImmediate()`，与process.nextTick()相似，但是语义不同。process.nextTick()延迟的回调在任何其他 I/O事件触发之前执行，而  setImmediate() 延迟的回调将在队列中所有已有的其他I/O事件之后执行。\n\n\n\n\n`process.nextTick()` 在任何已经调度的I/O之前运行，可能会导致 *I/O饥饿*（如递归调用），而使用 `setImmediate()` 不会有这种情况。\n\n \n\n## 4. 模块系统除了用于加载依赖关系的机制之外，还可以用于定义 API。\n\n 下面是一些在Node.js 中定义模块（暴露API）的模式：\n\n\n\n\n1）**命名导出**：将所有要公开的值赋给由 exports(或者 module.exports）引用对象的属性。这种方式导出的对象称为一组相关功能的容器或命名空间。\n\n\n\n\n```js\n\n// file1.js\n\nexports.log => {…}\n\nexports.get => {…}\n\n\n\n\n//file2.js\n\nlet logger = require('./file1.js')\n\nlogger.log()\n\nlogger.get()\n\n```\n\n\n\n\n2）**导出函数**：将整个 module.exports 变量重新分配给一个函数。优点是只暴露一个单一的功能，明确了模块的入口点，也容易理解。遵循“小接触面”的原则。\n\n\n\n\n3）**导出构造函数或类**：是导出函数模式的特别化。不同之处是使用构造函数导出的优点是，可以允许使用构造函数创建新实例，还能够扩展其原型并创建新类。\n\n\n\n\n```js\n\n//file1.js\n\n  function logger(name){…}\n\n  logger.prototype.log1 = function(){…\n\n  logger.prototype.log2 = function(){…\n\n  module.exports = logger\n\n//file2.js\n\n  const logger = require('./file1.js'\n\n  const dblogger = new logger()\n\n  dblogger.log1()\n\n  blogger.log2() \n\n```\n\n\n\n\n当然可以使用ES2015类：\n\n\n\n\n```js\n\n Class logger {\n\n    constructor(){…\n\n    log1(){…}\n\n    log2(){…}\n\n  }\n\n module.exports = logger\n\n```\n\n\n\n\n4）**导出实例**：由于导出的是一个实例，所以所有引用这个模块的模块总是的到同一个实例，从而共享它的转态。\n\n\n\n\n```js\n\n     modile.exports = new logger()\n\n```\n\n          一个模块甚至可以没有任何导出。这是通常用于修改其他模块或全局作用域内的对象，被称作 猴子补丁。"}