{"title":"React 的生命周期","articleTopic":"React 文档","content":"\n\n### 1. 生命周期题解\n\n\n![image](/imgs_from_article/1581050849793__article-img__屏幕快照2019-01-24下午12.53.45.png)\n\n\n#### 1） React v16.3 之前的的生命周期函数 示意图 :\n\n\n![image](/imgs_from_article/1581051216258__article-img__3813493706-5c1df81af0d25.png)\n\n\n#### 2）再看看16.3的示意图：\n\n\n![image](/imgs_from_article/1581051370678__article-img__1393330153-5c1df7d1a0e21.png)\n\n\n\n（以上两图来自 https://segmentfault.com/a/1190000017483690）\n\n\n\n\n### 2. 生命周期详解\n\n\n\n\n#### 2.1 挂载生命周期：\n\n这些方法会在组件实例被创建和插入DOM中时被调用：\n\n\n\n\n*`constructor()`*：constructor(props)\n\n\n\n\n>React 组件的构造函数将会在装配之前被调用.当为一个React.Component子类定义构造函数时，你应该在任何其他的表达式之前调用super(props)。否则，this.props在构造函数中将是未定义，并可能引发异常\n\n\n\n\n>可以基于属性来初始化状态。但是当心这种模式，因为状态将不会随着属性的更新而更新。保证属性和状态同步，你通常想要状态提升。\n\n\n\n\n*`static getDerivedStateFromProps()`*：static getDerivedStateFromProps(nextProps, prevState)\n\n>组件实例化后和接受新属性时将会调用 `getDerivedStateFromProps`。它应该返回一个对象来更新状态，或者返回null来表明新属性不需要更新任何状态。注意，如果父组件导致了组件的重新渲染，即使属性没有更新，这一方法也会被调用。\n\n>如果你只想处理变化，你可能想去比较新旧值。调用this.setState() 通常不会触发 getDerivedStateFromProps()。\n\n\n\n\n*`componentWillMount() / UNSAFE_componentWillMount()`*：\n\n>这一生命周期之前叫做componentWillMount。这一名字在17版前都有效。可以使用 `rename-unsafe-lifecycles codemod` 来自动更新你的组件。`UNSAFE_componentWillMount()` 在装配发生前被立刻调用。其在 `render()` 之前被调用，因此在这方法里同步地设置状态将不会触发重渲。避免在该方法中引入任何的副作用或订阅。对于这些使用场景，我们推荐使用 `constructor()` 来替代。这是唯一的会在服务端渲染调起的生命周期钩子函数。\n\n\n\n\n*`render()`*：\n\nrender()方法是必须的。\n\n在render()里面不能同时返回多个组件，必须嵌套，但是可以用数组让render（）返回多个元素：\n\n```js\n\nrender() {\n\n   return [\n\n     <li key=\"A\">First item</li>,\n\n     <li key=\"B\">Second item</li>，\n\n     <li key=\"C\">Third item</li>,\n\n    ];\n\n}\n\n```\n\n\n\n\n若 shouldComponentUpdate() 返回false，render()函数将不会被调用.\n\n当被调用时，其应该检查this.props 和 this.state并返回以下类型中的一个：\n\n\n\n\n- React元素。 通常是由 JSX 创建。该元素可能是一个原生DOM组件的表示，如 `<div/>`，或者是一个你定义的合成组件。\n\n- 字符串和数字。 这些将被渲染为 DOM 中的 text node。\n\n- Portals。 由 `ReactDOM.createPortal` 创建。\n\n- null。 什么都不渲染。\n\n- 布尔值。 什么都不渲染。（通常存在于 `return test && <Child />`写法，其中 test 是布尔值。）\n\n\n\n\n>render()函数应该纯净，意味着其不应该改变组件的状态，其每次调用都应返回相同的结果，同时不直接和浏览器交互。若需要和浏览器交互，将任务放在componentDidMount()阶段或其他的生命周期方法。保持render() 方法纯净使得组件更容易思考。\n\n\n\n\n*`componentDidMount()`*：componentDidMount()\n\n\n\n\n>componentDidMount()在组件被装配后立即调用。初始化使得DOM节点应该进行到这里。若你需要从远端加载数据，这是一个适合实现网络请求的地方。在该方法里设置状态将会触发重渲。\n\n\n\n\n>这一方法是一个发起任何订阅的好地方。如果你这么做了，别忘了在 componentWillUnmount() 退订。\n\n\n\n\n>在这个方法中调用setState()将会触发一次额外的渲染，但是它将在浏览器刷新屏幕之前发生。这保证了即使render()将会调用两次，但用户不会看到中间状态。谨慎使用这一模式，因为它常导致性能问题。然而，它对于像模态框和工具提示框这样的例子是必须的。这时，在渲染依赖DOM节点的尺寸或者位置的视图前，你需要先测量这些节点。\n\n\n\n\n#### 2.2 更新生命周期：\n\n\n\n\n属性或状态的改变会触发一次更新。当一个组件在被重渲时，这些方法将会被调用：\n\n*`componentWillReceiveProps() / UNSAFE_componentWillReceiveProps()`*：UNSAFE_componentWillReceiveProps(nextProps)\n\n\n\n\n>`UNSAFE_componentWillReceiveProps()` 在装配了的组件接收到新属性前调用。若你需要更新状态以响应属性改变（例如，重置它），你可能需对比 `this.props` 和 `nextProps` 并在该方法中使用 this.setState() 处理状态改变。推荐你使用 `getDerivedStateFromProps` 生命周期而不是 `UNSAFE_componentWillReceiveProps`。\n\n\n\n\n*`static getDerivedStateFromProps()`*（挂载、更新都有）\n\n\n\n\n*`shouldComponentUpdate()`*：shouldComponentUpdate(nextProps, nextState)\n\n\n\n\n>当接收到新属性或状态时，shouldComponentUpdate() 在渲染前被调用。默认为true。该方法并不会在初始化渲染或当使用 forceUpdate()时被调用；\n\n\n\n\n>手写 `shouldComponentUpdate（）`，你可能需要用 this.props 和 nextProps 以及 this.state 和 nextState 比较，并返回 false 以告诉 React更新可以被忽略；\n\n\n\n\n>若你判定一个具体的组件很慢，你可能需要调整其从React.PureComponent继承，其实现了带有浅属性和状态比较的shouldComponentUpdate()。\n\n\n\n\n*`componentWillUpdate() / UNSAFE_componentWillUpdate()`*：UNSAFE_componentWillUpdate(nextProps, nextState)\n\n\n\n\n- 当接收到新属性或状态时，UNSAFE_componentWillUpdate()为在渲染前被立即调用。在更新发生前，使用该方法是一次准备机会。该方法不会在初始化渲染时调用。\n\n- 注意你不能在这调用this.setState()，若你需要更新状态响应属性的调整，使用getDerivedStateFromProps() 代替。\n\n- 这一生命周期之前叫做componentWillUpdate。这一名字在17版前都有效。可以使用 `rename-unsafe-lifecycles codemod `来自动更新你的组件。\n\n- 若 `shouldComponentUpdate()` 返回false，UNSAFE_componentWillUpdate()将不会被调用。\n\n\n\n\n*`render()`*（挂载、更新都有）\n\n\n\n\n*`getSnapshotBeforeUpdate()`*\n\n>getSnapshotBeforeUpdate()在最新的渲染输出提交给DOM前将会立即调用。它让你的组件能在当前的值可能要改变前获得它们。这一生命周期返回的任何值将会 作为参数被传递给componentDidUpdate()。\n\n\n\n\n*`componentDidUpdate()`*：componentDidUpdate(prevProps, prevState)\n\n\n\n\n>当组件被更新时，使用该方法是操作DOM的一次机会。这也是一个适合发送请求的地方，要是你对比了当前属性和之前属性（例如，如果属性没有改变那么请求也就没必要了）。\n\n\n\n\n>componentDidUpdate() 会在更新发生后立即被调用.\n\n\n\n\n>若shouldComponentUpdate()返回false，componentDidUpdate()将不会被调用；\n\n\n\n\n#### 2.3 卸载：当一个组件被从DOM中移除时，该方法被调用：\n\n\n\n\n*`componentWillUnmount()`*\n\n>componentWillUnmount()在组件被卸载和销毁之前立刻调用。可以在该方法里处理任何必要的清理工作，例如解绑定时器，取消网络请求，清理任何在componentDidMount环节创建的DOM元素。\n\n\n\n\n#### 2.4 错误处理：在渲染过程中发生错误时会被调用：\n\n\n\n\n*`componentDidCatch()`*：componentDidCatch(error, info)\n\n>如果定义了这一生命周期方法，一个类组件将成为一个错误边界。在错误边界中调用setState()让你捕捉当前树之下未处理的JavaScript错误，并显示回退的用户界面。只使用错误边界来恢复异常，而不要尝试将它们用于控制流。错误边界捕捉渲染期间、在生命周期方法中和在它们之下整棵树的构造函数中的错误。\n\n "}